# Отчет по лабораторной работе №1
# Архитектура СУБД и конфигурация PostgreSQL 16

## Сведения о студенте

**Дата:** 19.10.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисовчи  

## Цель работы

Изучить архитектуру сервера PostgreSQL на уровне процессов и памяти, а также механизмы управления параметрами конфигурации через файлы и SQL‑команды на уровне всего экземпляра и отдельного сеанса с использованием представлений pg_settings и pg_file_settings.

## Теоретическая часть

### Изученные концепции

- Архитектура «процесс на подключение» (postmaster и backend‑процессы), взаимодействующие через общую память (shared buffers) и локальные области памяти процессов.

- Конфигурационные файлы postgresql.conf, postgresql.auto.conf и дополнительные файлы include_dir, определяющие значения параметров экземпляра.

- Системные представления pg_settings и pg_file_settings и контексты параметров (postmaster, sighup, user), определяющие порядок применения изменений.

### Ключевые термины

- **postgresql.conf:** основной конфигурационный файл сервера PostgreSQL, считываемый при старте и при перечитывании конфигурации, в котором задаются глобальные параметры экземпляра.

- **postgresql.auto.conf:** конфигурационный файл, автоматически управляемый командами ALTER SYSTEM и считываемый последним поверх postgresql.conf для задания параметров на уровне кластера через SQL.

- **pg_settings:** представление, содержащее действующие значения параметров, их источник, контекст и информацию о необходимости перезапуска для применения изменений.

## Практическая часть

### Модуль 1: Исследование параметров и файлов конфигурации

#### Задача 1: Текущая конфигурация

**Цель:** Определить расположение файла postgresql.conf.

**Выполненные действия:**

```sql
SHOW config_file;
```

**Результаты:**

```bash
                config_file                 
--------------------------------------------
 /home/student/pgsql16/data/postgresql.conf
(1 row)
```

**Выводы и объяснения:**

Параметр config_file показывает фактический путь к основному конфигурационному файлу, который в пакетах Ubuntu выносится за пределы каталога данных PGDATA и передается серверу через параметр -c config_file=... в командной строке запуска.

#### Задача 2: Анализ параметров

**Цель:** Найти параметры разных контекстов (postmaster, sighup, user).

**Выполненные действия:**

```sql
-- Параметры, требующие перезапуска
SELECT name, setting, unit, context
FROM pg_settings
WHERE context = 'postmaster';

-- Параметры с контекстом sighup
SELECT name, setting, context
FROM pg_settings
WHERE context = 'sighup'
LIMIT 3;

-- Параметры с контекстом user
SELECT name, setting, context
FROM pg_settings
WHERE context = 'user'
LIMIT 3;
```

**Результаты:**

```bash
# Фрагмент для context = 'postmaster'
                name                 |                  setting                   | unit |  context   
-------------------------------------+--------------------------------------------+------+------------
 archive_mode                        | off                                        |      | postmaster
 autovacuum_freeze_max_age           | 200000000                                  |      | postmaster
 autovacuum_max_workers              | 3                                          |      | postmaster
 autovacuum_multixact_freeze_max_age | 400000000                                  |      | postmaster
 bonjour                             | off                                        |      | postmaster
 bonjour_name                        |                                            |      | postmaster
 cluster_name                        |                                            |      | postmaster
 config_file                         | /home/student/pgsql16/data/postgresql.conf |      | postmaster
 data_directory                      | /home/student/pgsql16/data                 |      | postmaster
 data_sync_retry                     | off                                        |      | postmaster
 debug_io_direct                     |                                            |      | postmaster
 dynamic_shared_memory_type          | posix                                      |      | postmaster
 event_source                        | PostgreSQL                                 |      | postmaster
 external_pid_file                   |                                            |      | postmaster
 hba_file                            | /home/student/pgsql16/data/pg_hba.conf     |      | postmaster
 hot_standby                         | on                                         |      | postmaster
 huge_page_size                      | 0                                          | kB   | postmaster
 huge_pages                          | try                                        |      | postmaster
 ident_file                          | /home/student/pgsql16/data/pg_ident.conf   |      | postmaster
 ignore_invalid_pages                | off                                        |      | postmaster
 jit_provider                        | llvmjit                                    |      | postmaster
 listen_addresses                    | localhost                                  |      | postmaster
 logging_collector                   | off                                        |      | postmaster
 max_connections                     | 100                                        |      | postmaster
 max_files_per_process               | 1000                                       |      | postmaster
 max_locks_per_transaction           | 64                                         |      | postmaster
 max_logical_replication_workers     | 4                                          |      | postmaster
 max_pred_locks_per_transaction      | 64                                         |      | postmaster
 max_prepared_transactions           | 0                                          |      | postmaster
 max_replication_slots               | 10                                         |      | postmaster
 max_wal_senders                     | 10                                         |      | postmaster
 max_worker_processes                | 8                                          |      | postmaster
 min_dynamic_shared_memory           | 0                                          | MB   | postmaster
 old_snapshot_threshold              | -1                                         | min  | postmaster
 port                                | 5555                                       |      | postmaster
 recovery_target                     |                                            |      | postmaster
 recovery_target_action              | pause                                      |      | postmaster
 recovery_target_inclusive           | on                                         |      | postmaster
 recovery_target_lsn                 |                                            |      | postmaster
 recovery_target_name                |                                            |      | postmaster
 recovery_target_time                |                                            |      | postmaster
 recovery_target_timeline            | latest                                     |      | postmaster
 recovery_target_xid                 |                                            |      | postmaster
 reserved_connections                | 0                                          |      | postmaster
 shared_buffers                      | 16384                                      | 8kB  | postmaster
 shared_memory_type                  | mmap                                       |      | postmaster
 shared_preload_libraries            |                                            |      | postmaster
 superuser_reserved_connections      | 3                                          |      | postmaster
 track_activity_query_size           | 1024                                       | B    | postmaster
 track_commit_timestamp              | off                                        |      | postmaster
 unix_socket_directories             | /tmp                                       |      | postmaster
 unix_socket_group                   |                                            |      | postmaster
 unix_socket_permissions             | 0777                                       |      | postmaster
 wal_buffers                         | 512                                        | 8kB  | postmaster
 wal_decode_buffer_size              | 524288                                     | B    | postmaster
 wal_level                           | replica                                    |      | postmaster
 wal_log_hints                       | off                                        |      | postmaster
(57 rows)

# Примеры context = 'sighup'
          name           |  setting   | context 
-------------------------+------------+---------
 archive_cleanup_command |            | sighup
 archive_command         | (disabled) | sighup
 archive_library         |            | sighup
(3 rows)

# Примеры context = 'user'
        name         | setting | context 
---------------------+---------+---------
 application_name    | psql    | user
 array_nulls         | on      | user
 backend_flush_after | 0       | user
(3 rows)
```

**Выводы и объяснения:**

Параметры с контекстом postmaster применяются только при старте сервера, поэтому изменение их значений требует перезапуска экземпляра. Параметры sighup пересчитываются при перечитывании конфигурации (pg_reload_conf или сигнал SIGHUP), а параметры user можно менять непосредственно внутри сеанса без перезапуска и без перечитывания файлов.

#### Задача 3: Анализ файлов

**Цель:** Определить, из каких файлов и с какими значениями были прочитаны shared_buffers и work_mem.

**Выполненные действия:**

```sql
SELECT sourcefile, sourceline, name, setting, applied, error
FROM pg_file_settings
WHERE name IN ('shared_buffers', 'work_mem');
```

**Результаты:**

```bash
                 sourcefile                 | sourceline |      name      | setting | applied | error 
--------------------------------------------+------------+----------------+---------+---------+-------
 /home/student/pgsql16/data/postgresql.conf |        130 | shared_buffers | 128MB   | t       | 
(1 row)
```

**Выводы и объяснения:**

Поле sourcefile указывает, из какого конкретного файла пришло значение параметра, а applied показывает, будет ли оно задействовано после перечитывания конфигурации; строки с applied = false могут быть переопределены более поздними записями или содержать ошибки.

### Модуль 2: Управление параметрами на уровне экземпляра

#### Задача 1: Изменение через ALTER SYSTEM

**Цель:** Установить новое значение work_mem через ALTER SYSTEM и применить изменение.

**Выполненные действия:**

```sql
-- Установка параметра
ALTER SYSTEM SET work_mem TO '16MB';

-- Просмотр postgresql.auto.conf
SELECT pg_read_file('postgresql.auto.conf');

-- Перечитывание конфигурации
SELECT pg_reload_conf();

-- Проверка значения и источника
SELECT name, setting, unit, source, sourcefile, sourceline
FROM pg_settings
WHERE name = 'work_mem';
```

**Результаты:**

```bash
# Фрагмент postgresql.auto.conf
                     pg_read_file                      
-------------------------------------------------------
 # Do not edit this file manually!                    +
 # It will be overwritten by the ALTER SYSTEM command.+
 work_mem = '16MB'                                    +
 
(1 row)

 pg_reload_conf 
----------------
 t
(1 row)

# После pg_reload_conf()
   name   | setting | unit |       source       |                   sourcefile                    | sourceline 
----------+---------+------+--------------------+-------------------------------------------------+------------
 work_mem | 16384   | kB   | configuration file | /home/student/pgsql16/data/postgresql.auto.conf |          3
(1 row)
```

**Выводы и объяснения:**

Команда ALTER SYSTEM записывает значение параметра в файл postgresql.auto.conf, но до вызова pg_reload_conf фактическое значение в pg_settings не меняется. После перечитывания конфигурации источник параметра становится configuration file с указанием строки в postgresql.auto.conf, что отражает приоритет этого файла над postgresql.conf и include‑файлами.

#### Задача 2: Изменение через дополнительный файл

**Цель:** Установить log_min_duration_statement через файл в include_dir.

**Выполненные действия:**

```sql
-- Проверка каталога include_dir
SELECT current_setting('config_file');
```

```bash
mkdir /home/student/pgsql16/data/conf.d/
nano /home/student/pgsql16/data/postgresql.conf
# строка:
# include_dir = '/home/student/pgsql16/data/conf.d/'

nano /home/student/pgsql16/data/conf.d/log_min_duration.conf
# строка:
# log_min_duration_statement = 500
```

```sql
-- Перечитывание конфигурации
SELECT pg_reload_conf();

-- Проверка в pg_settings и pg_file_settings
SELECT name, setting, source, sourcefile
FROM pg_settings
WHERE name = 'log_min_duration_statement';

SELECT sourcefile, sourceline, name, setting, applied, error
FROM pg_file_settings
WHERE name = 'log_min_duration_statement';
```

**Результаты:**

```bash
              current_setting               
--------------------------------------------
 /home/student/pgsql16/data/postgresql.conf
(1 row)

            name            | setting |       source       |                       sourcefile                        
----------------------------+---------+--------------------+---------------------------------------------------------
 log_min_duration_statement | 500     | configuration file | /home/student/pgsql16/data/conf.d/log_min_duration.conf
(1 row)

                       sourcefile                        | sourceline |            name            | setting | applied | error 
---------------------------------------------------------+------------+----------------------------+---------+---------+-------
 /home/student/pgsql16/data/conf.d/log_min_duration.conf |          1 | log_min_duration_statement | 500     | t       | 
(1 row)
```

**Выводы и объяснения:**

Параметр с контекстом sighup можно задать в дополнительном файле, подключенном через include_dir, и достаточно перечитать конфигурацию без перезапуска сервера, после чего pg_settings и pg_file_settings фиксируют новый источник и значение.

#### Задача 3: Ошибка в конфигурации

**Цель:** Смоделировать синтаксическую ошибку в конфигурации, найти её через pg_file_settings и исправить.

**Выполненные действия:**

```sql
-- Буква O вместо цифры 0
\! echo "max_connections = 5O" | sudo tee /home/student/pgsql16/data/conf.d/max_connections.conf

-- Просмотр ошибки в pg_file_settings
SELECT sourcefile, sourceline, name, setting, applied, error
FROM pg_file_settings
WHERE name = 'max_connections' \gx
```

```bash
# Перезапуск сервера
pg_ctl restart

# Исправление ошибки
echo "max_connections = 50" | sudo tee /home/student/pgsql16/data/conf.d/max_connections.conf

# Перезапуск сервера
pg_ctl restart
```

```sql
SHOW max_connections;
```

**Результаты:**

```bash
# Результат просмотра
-[ RECORD 1 ]------------------------------------------------------
sourcefile | /home/student/pgsql16/data/postgresql.conf
sourceline | 65
name       | max_connections
setting    | 100
applied    | f
error      | 
-[ RECORD 2 ]------------------------------------------------------
sourcefile | /home/student/pgsql16/data/conf.d/max_connections.conf
sourceline | 1
name       | max_connections
setting    | 5O
applied    | f
error      | setting could not be applied

# Перезапуск сервера
waiting for server to shut down.... done
server stopped
waiting for server to start....2025-10-19 11:19:21.165 MSK [13271] LOG:  invalid value for parameter "max_connections": "5O"
2025-10-19 11:19:21.166 MSK [13271] FATAL:  configuration file "/home/student/pgsql16/data/conf.d/max_connections.conf" contains errors
 stopped waiting
pg_ctl: could not start server
Examine the log output.

# Проверка после исправления
 max_connections 
-----------------
 50
(1 row)
```

**Выводы и объяснения:**
Представление pg_file_settings фиксирует ошибочные строки и помечает их applied = false с текстом ошибки в столбце error, а при наличии критичных ошибок сервер отказывается стартовать до исправления конфигурации. После корректировки значения и успешного запуска можно убедиться через SHOW, что параметр применился с новым значением.

### Модуль 3: Управление параметрами на уровне сеанса

#### Задача 1: Команда SET

**Цель:** Показать транзакционность изменения параметров через SET.

**Выполненные действия:**

```sql
-- Проверка исходного значения
SHOW work_mem;

-- Изменение в сеансе
SET work_mem TO '32MB';
SHOW work_mem;

-- Открытие транзакции и изменение
BEGIN;
SET work_mem TO '64MB';
SHOW work_mem;
ROLLBACK;

-- Проверка после отката
SHOW work_mem;
```

**Результаты:**

```bash
# До изменений
 work_mem 
----------
 16MB
(1 row)

# После SET
 work_mem 
----------
 32MB
(1 row)

# Внутри транзакции
 work_mem 
----------
 64MB
(1 row)

# После ROLLBACK
 work_mem 
----------
 32MB
(1 row)
```

**Выводы и объяснения:**

Команда SET меняет значение параметра на уровне сеанса до его завершения, а изменения внутри транзакции подчиняются общим правилам транзакционности: при ROLLBACK параметры возвращаются к значениям на момент начала транзакции.

#### Задача 2: Команда SET LOCAL

**Цель:** Показать отличие SET LOCAL от обычного SET.

**Выполненные действия:**

```sql
-- Исходное значение сеанса
RESET work_mem;
SHOW work_mem;

BEGIN;
SET LOCAL work_mem TO '64MB';
SHOW work_mem;
COMMIT;

SHOW work_mem;
```

**Результаты:**

```bash
# Изначально
 work_mem 
----------
 16MB
(1 row)

# Внутри транзакции
 work_mem 
----------
 64MB

# После COMMIT
 work_mem 
----------
 16MB
```

**Выводы и объяснения:**

SET LOCAL ограничивает действие изменения концом текущей транзакции, после COMMIT или ROLLBACK значение возвращается к сеансовому значению, тогда как обычный SET без LOCAL сохраняет новое значение до конца сеанса.

#### Задача 3: Пользовательский параметр

**Цель:** Создать пользовательский параметр и прочитать его значение.

**Выполненные действия:**

```sql
-- Установка пользовательского параметра
SELECT set_config('app.my_setting', 'demo_value', false);

-- Чтение значения
SELECT current_setting('app.my_setting');
```

**Результаты:**

```bash
 set_config 
------------
 demo_value
(1 row)

 current_setting 
-----------------
 demo_value
(1 row)
```

**Выводы и объяснения:**

Пользовательские параметры (GUC) должны содержать точку в имени и могут использоваться как глобальные переменные сеанса, задаваемые через set_config/SET и считываемые через current_setting.

## Результаты выполнения

### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
| ------ | ------ | ------ | ------------------- | 
| 1 | 1 | ✅ Выполнено | config_file указывает реальный путь postgresql.conf, который в дистрибутивах может отличаться от PGDATA.   |
| 1 | 2 | ✅ Выполнено | Контекст postmaster требует перезапуска, sighup - перечитывания конфигурации, user - позволяет менять параметры в сеансе. |
| 1 | 3 | ✅ Выполнено | pg_file_settings показывает источник, значение и признак applied для shared_buffers и work_mem.  |
| 2 | 1 | ✅ Выполнено | ALTER SYSTEM записывает значения в postgresql.auto.conf и требует pg_reload_conf для применения. |
| 2 | 2 | ✅ Выполнено | Параметр log_min_duration_statement успешно задан в дополнительном файле include_dir.  |
| 2 | 3 | ✅ Выполнено | Ошибки конфигурации фиксируются в pg_file_settings и журналах, мешая запуску сервера до исправления.  |
| 3 | 1 | ✅ Выполнено | SET изменяет параметры на уровне сеанса, изменения внутри транзакции откатываются вместе с ней.  |
| 3 | 2 | ✅ Выполнено | SET LOCAL действует только до конца текущей транзакции.  |
| 3 | 3 | ✅ Выполнено | Пользовательский параметр app.my_setting используется как переменная сеанса через current_setting.    |
​
## Анализ и выводы

### Основные наблюдения

1. Параметры с разными контекстами (postmaster, sighup, user) требуют разного уровня вмешательства: от простого pg_reload_conf до полного перезапуска экземпляра, что важно учитывать при планировании изменений в продуктивной среде.

2. pg_settings и pg_file_settings дополняют друг друга: первое показывает активные значения и источник, второе - содержимое файлов и ошибки, что позволяет безопасно диагностировать конфигурацию.

3. Управление параметрами через ALTER SYSTEM и через SET/SET LOCAL покрывает потребности как долгосрочной настройки кластера, так и временных изменений для отдельных сеансов и транзакций.

### Сравнительный анализ

- Контексты параметров:
    
    - postmaster - изменение только при перезапуске (например, max_connections, shared_buffers).
    
    - sighup - достаточно перечитать конфигурацию без перезапуска (например, логирование).
    
    - user - допускает динамическое изменение внутри сеанса любой командой SET.

- ALTER SYSTEM vs SET / SET LOCAL:
    
    - ALTER SYSTEM изменяет параметр на уровне всего кластера, записывая его в postgresql.auto.conf, и требует pg_reload_conf или перезапуска для применения.
    
    - SET меняет параметр в текущем сеансе до его завершения, а SET LOCAL ограничивает изменение границами транзакции, не затрагивая другие сеансы.
