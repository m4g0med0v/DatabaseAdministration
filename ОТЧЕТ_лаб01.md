# Архитектура СУБД и конфигурация PostgreSQL

## Сведения о студенте
**Дата:** 2024-12-19
**Семестр:** 7 
**Группа:** ПИЖ-Б-О-22-1
**Дисциплина:** Администрирование баз данных
**Студент:** Магомедов Имран Борисович

## Цель работы
Изучить базовые компоненты архитектуры PostgreSQL и получить практические навыки управления конфигурационными параметрами сервера на разных уровнях.

## Теоретическая часть

### Изученные концепции
- Архитектура PostgreSQL (процессы, память)
- Уровни конфигурации (экземпляр, сеанс, транзакция)
- Файлы конфигурации и их приоритеты
- Представления системного каталога для работы с параметрами

### Ключевые термины
- **postmaster:** основной процесс PostgreSQL, управляющий кластером
- **backend:** обслуживающий процесс для клиентского соединения
- **shared_buffers:** общая память для буферного кеша
- **WAL:** Write-Ahead Log (журнал предзаписи)
- **context:** контекст параметра, определяющий способ его изменения

## Практическая часть

### Часть 1: Исследование параметров и файлов конфигурации

#### Задача 1: Текущая конфигурация
**Цель:** Определить расположение основного файла конфигурации

```sql
-- Подключаемся к серверу
psql

-- Определяем расположение config_file
SHOW config_file;
```

**Результаты:**
```
                config_file
--------------------------------------------
 /home/student/pgsql16/data/postgresql.conf
(1 row)
```

#### Задача 2: Анализ параметров
**Цель:** Изучить параметры с разными контекстами

```sql
-- Параметры, требующие перезагрузки сервера
SELECT name, setting, unit, context
FROM pg_settings
WHERE context = 'postmaster'
LIMIT 5;

-- Параметры с контекстом sighup
SELECT name, setting, unit
FROM pg_settings
WHERE context = 'sighup'
LIMIT 3;

-- Параметры с контекстом user
SELECT name, setting, unit
FROM pg_settings
WHERE context = 'user'
LIMIT 3;
```

**Результаты:**
```
-- Параметры postmaster
                name                 |  setting  | unit |  context
-------------------------------------+-----------+------+------------
 archive_mode                        | off       |      | postmaster
 autovacuum_freeze_max_age           | 200000000 |      | postmaster
 autovacuum_max_workers              | 3         |      | postmaster
 autovacuum_multixact_freeze_max_age | 400000000 |      | postmaster
 bonjour                             | off       |      | postmaster
(5 rows)

-- Параметры sighup
          name           |  setting   | unit
-------------------------+------------+------
 archive_cleanup_command |            |
 archive_command         | (disabled) |
 archive_library         |            |
(3 rows)

-- Параметры user
        name         | setting | unit
---------------------+---------+------
 application_name    | psql    |
 array_nulls         | on      |
 backend_flush_after | 0       | 8kB
(3 rows)
```

#### Задача 3: Анализ файлов конфигурации
**Цель:** Определить источники параметров shared_buffers и work_mem

```sql
-- Источники параметров
SELECT name, setting, sourcefile, sourceline, applied
FROM pg_file_settings
WHERE name IN ('shared_buffers', 'work_mem')
ORDER BY name, sourceline;
```

**Результаты:**
```
-[ RECORD 1 ]------------------------------------------
name       | shared_buffers
setting    | 128MB
sourcefile | /home/student/pgsql16/data/postgresql.conf
sourceline | 130
applied    | t
```

### Часть 2: Управление параметрами на уровне экземпляра

#### Задача 1: Изменение через ALTER SYSTEM
**Цель:** Установить параметр work_mem через ALTER SYSTEM

```sql
-- Устанавливаем новое значение
ALTER SYSTEM SET work_mem = '8MB';

-- Проверяем запись в postgresql.auto.conf
SELECT pg_read_file('postgresql.auto.conf') AS auto_conf_content;

-- Перечитываем конфигурацию
SELECT pg_reload_conf();

-- Проверяем новое значение и источник
SELECT name, setting, unit, source, sourcefile, sourceline
FROM pg_settings
WHERE name = 'work_mem';
```

**Результаты:**
```
-- Устанавливаем новое значение
ALTER SYSTEM

-- Проверяем запись в postgresql.auto.conf
                   auto_conf_content
-------------------------------------------------------
 # Do not edit this file manually!                    +
 # It will be overwritten by the ALTER SYSTEM command.+
 work_mem = '8MB'                                     +

(1 row)

-- Перечитываем конфигурацию
 pg_reload_conf
----------------
 t
(1 row)

-- Проверяем новое значение и источник
-[ RECORD 1 ]-----------------------------------------------
name       | work_mem
setting    | 8192
unit       | kB
source     | configuration file
sourcefile | /home/student/pgsql16/data/postgresql.auto.conf
sourceline | 3
```

#### Задача 2: Изменение через дополнительный файл
**Цель:** Установить параметр через дополнительный файл конфигурации

```bash
# Создаем каталог conf.d внутри PGDATA
mkdir -p /home/student/pgsql16/data/conf.d

# Создаем файл конфигурации
echo "log_min_duration_statement = 1000" > /home/student/pgsql16/data/conf.d/custom.conf

# Открываем основной конфигурационный файл
nvim /home/student/pgsql16/data/postgresql.conf

# Раскоментируем строку и добавим путь в папке с дополнительными конфигами:
include_dir = 'conf.d'
```

```sql
-- Перечитываем конфигурацию
SELECT pg_reload_conf();

-- Проверяем изменение
SELECT name, setting, unit, source, sourcefile
FROM pg_settings
WHERE name = 'log_min_duration_statement';
```

**Результаты:**
```
-[ RECORD 1 ]---------------------------------------------
name       | log_min_duration_statement
setting    | 1000
unit       | ms
source     | configuration file
sourcefile | /home/student/pgsql16/data/conf.d/custom.conf
```

#### Задача 3: Ошибка в конфигурации
**Цель:** Найти и исправить ошибку в конфигурации

```bash
# Намеренно вносим ошибку
echo "shared_buffers = invalid_value" | sudo tee /home/student/pgsql16/data/conf.d/error.conf
```

```sql
-- Пытаемся перечитать конфигурацию
SELECT pg_reload_conf();

-- Ищем ошибку в pg_file_settings
SELECT name, setting, sourcefile, sourceline, applied, error
FROM pg_file_settings
WHERE error IS NOT NULL;

-- Исправляем ошибку
-- В терминале:
-- sudo bash -c 'echo "shared_buffers = 256MB" > /home/student/pgsql16/data/conf.d/error.conf'

-- Снова перечитываем
SELECT pg_reload_conf();

-- Проверяем исправление
SELECT name, setting, applied, error
FROM pg_file_settings
WHERE sourcefile LIKE '%error.conf';
```

**Результаты:**
```
-- До исправления:
-[ RECORD 1 ]--+--
pg_reload_conf | t

-[ RECORD 1 ]--------------------------------------------
name       | shared_buffers
setting    | invalid_value
sourcefile | /home/student/pgsql16/data/conf.d/error.conf
sourceline | 1
applied    | f
error      | setting could not be applied


-- После исправления:
pg_reload_conf
----------------
t
(1 row)

     name      | setting | applied |            error
----------------+---------+---------+------------------------------
shared_buffers | 256MB   | f       | setting could not be applied
(1 row)
```

### Часть 3: Управление параметрами на уровне сеанса

#### Задача 1: Команда SET
**Цель:** Изменить параметр на уровне сеанса

```sql
-- Проверяем текущее значение
SHOW work_mem;

-- Изменяем параметр
SET work_mem = '16MB';

-- Проверяем новое значение
SHOW work_mem;

-- Проверяем значение после перезахода
SHOW work_mem;
```

**Результаты:**
```
-- До SET:
work_mem
----------
8MB
(1 row)

-- После SET:
work_mem
----------
16MB
(1 row)

-- После перезахода:
 work_mem
----------
 8MB
(1 row)

```

**Выводы:** Команда SET изменяет параметр до конца сеанса. ROLLBACK отменяет только изменения данных в транзакции, но не изменения параметров, сделанные через SET.

#### Задача 2: Команда SET LOCAL
**Цель:** Изменить параметр на уровне транзакции

```sql
-- Начинаем транзакцию
BEGIN;

-- Изменяем параметр только для транзакции
SET LOCAL work_mem = '32MB';

-- Проверяем значение внутри транзакции
SHOW work_mem;

-- Завершаем транзакцию
COMMIT;

-- Проверяем значение после COMMIT
SHOW work_mem;
```

**Результаты:**
```
-- Внутри транзакции после SET LOCAL:
work_mem
----------
32MB
(1 row)

-- После COMMIT:
work_mem
----------
8MB
(1 row)
```

**Выводы:** SET LOCAL изменяет параметр только до конца текущей транзакции. После COMMIT значение возвращается к предыдущему.

#### Задача 3: Пользовательский параметр
**Цель:** Создать и использовать пользовательский параметр

```sql
-- Устанавливаем пользовательский параметр
SET app.my_setting = 'custom_value';

-- Читаем значение
SELECT current_setting('app.my_setting');

-- Альтернативный способ
SHOW app.my_setting;
```

**Результаты:**
```
current_setting
-----------------
custom_value
(1 row)

app.my_setting
----------------
custom_value
(1 row)
```

## Анализ и выводы

### Основные наблюдения
1. **Иерархия конфигурации:** PostgreSQL имеет четкую иерархию применения параметров - от файлов конфигурации до уровня сеанса и транзакции
2. **Различные контексты:** Параметры имеют разные контексты (postmaster, sighup, user), определяющие сложность их изменения
3. **Механизмы восстановления:** Система предоставляет инструменты для обнаружения и исправления ошибок конфигурации

### Сравнительный анализ способов управления параметрами

| Способ | Уровень | Сложность изменения | Постоянность |
|--------|---------|---------------------|--------------|
| ALTER SYSTEM | Экземпляр | Требует reload/restart | Постоянно |
| Файлы .conf | Экземпляр | Требует reload/restart | Постоянно |
| SET | Сеанс | Немедленно | До конца сеанса |
| SET LOCAL | Транзакция | Немедленно | До конца транзакции |

### Проблемы и решения
| Проблема | Причина | Решение |
|----------|---------|---------|
| Ошибка в конфигурации | Неверный синтаксис значения | Использование pg_file_settings для диагностики |
| Не применяются изменения | Требуется перезагрузка | Проверка context в pg_settings |

## Ответы на контрольные вопросы

### Вопросы из задания

1. **"Объяснение разницы между контекстами параметров postmaster, sighup и user"**
   **postmaster** - параметры, требующие перезагрузки сервера (изменяются только при старте)
   **sighup** - параметры, требующие перечитывания конфигурации (pg_reload_conf)
   **user** - параметры, которые можно изменять на лету в сеансе

2. **"Объяснение разницы между применением изменений через ALTER SYSTEM и через SET/SET LOCAL"**
   **ALTER SYSTEM** изменяет параметры на уровне всего экземпляра через postgresql.auto.conf, требует перечитывания конфигурации
   **SET** изменяет параметры только для текущего сеанса
   **SET LOCAL** изменяет параметры только для текущей транзакции

3. **"Описание процедуры поиска и исправления ошибки в конфигурационном файле"**
   - Обнаружить ошибку через pg_file_settings (столбец error)
   - Исправить ошибочный файл конфигурации
   - Выполнить SELECT pg_reload_conf()
   - Проверить исправление через pg_file_settings

## Приложения

### Конфигурационные файлы
```bash
# /home/student/pgsql16/data/conf.d/custom.conf
log_min_duration_statement = 1000
```

### SQL-скрипты
Все выполненные команды представлены в основном тексте отчета.

### Системные команды
```bash
# Команды для работы с конфигурацией
sudo systemctl status postgresql
sudo pg_ctlcluster 16 main status
```