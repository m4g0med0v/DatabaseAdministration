# Отчет по лабораторной работе №8  
# Резервное копирование и управление доступом

## Сведения о студенте

**Дата:** 06.12.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович  

## Цель работы

Освоение методов логического и физического резервного копирования в PostgreSQL, включая использование утилит pg_dump, pg_dumpall и pg_basebackup, а также практическое выполнение восстановления данных и сценариев Point-in-Time Recovery (PITR) с применением WAL-архивации. Дополнительно - углубление навыков управления правами доступа пользователей с использованием ролей, привилегий и механизмов разграничения доступа в PostgreSQL 16.

## Теоретическая часть

### Изученные концепции

- **Логическое резервное копирование (pg_dump, pg_dumpall):** Создает дамп в виде набора SQL-команд или в специальном формате, позволяющем восстановить структуру и данные базы, удобно для выборочного восстановления и миграции между версиями PostgreSQL.

- **Физическое резервное копирование (pg_basebackup):** Копирует файловую структуру кластера PostgreSQL, обеспечивает быстрое полное восстановление, обычно используется вместе с WAL-архивацией для поддержки PITR.

- **WAL-архивация и PITR:** Непрерывное сохранение журналов предзаписи (WAL) позволяет восстановить систему на произвольный момент времени после создания базовой физической копии, что критично для защиты от логических ошибок и сбоев.

- **Обновление сервера PostgreSQL:** Переход на новую мажорную версию часто выполняется через логический дамп/восстановление, что обеспечивает совместимость и возможность изменения структуры данных при миграции.

- **Управление доступом и роли:** PostgreSQL использует роли (пользовательские и групповые) и систему привилегий для гибкого разграничения доступа к базам, схемам, таблицам и другим объектам.

### Ключевые термины

- **Логический дамп:** Файл или набор файлов, содержащий команды создания объектов и вставки данных, формируемый утилитами pg_dump и pg_dumpall.

- **Физическая резервная копия:** Побайтовое копирование каталога данных кластера (data directory), выполняемое, например, с помощью pg_basebackup, пригодное для быстрого восстановления и репликации.

- **WAL (Write-Ahead Log):** Журнал предзаписи, в который сначала фиксируются изменения, а затем они применяются к основным файлам данных, что обеспечивает надежность и возможность восстановления.

- **PITR (Point-in-Time Recovery):** Механизм восстановления базы данных к состоянию на определенный момент времени за счет сочетания базовой физической копии и последовательного проигрывания архивированных WAL-сегментов.

- **Роль (Role):** Сущность, представляющая пользователя или группу пользователей, которая может владеть объектами и иметь привилегии, включая право входа (LOGIN) и администрирования (CREATEDB, CREATEROLE и т.д.).

- **Привилегии (Privileges):** Разрешения на выполнение операций над объектами базы данных (SELECT, INSERT, UPDATE, DELETE, CONNECT и др.), которыми можно управлять через команды GRANT и REVOKE.

## Практическая часть

### Модуль 1: Управление доступом (Повторение и закрепление)

#### Задача 1: Настройка привилегий

**Цель:** Настроить разграничение доступа в PostgreSQL с помощью ролей и привилегий так, чтобы роль writer могла создавать и изменять объекты в схеме public, а роль reader имела только права на чтение существующих и будущих таблиц, создаваемых writer, без возможности модификации данных.

**Выполненные действия:**

```sql
-- 1. Создание базы для эксперимента с доступом
CREATE DATABASE access_db;

-- 2. Создание групповых ролей
CREATE ROLE writer;
CREATE ROLE reader;

-- 3. Создание пользователей и включение их в групповые роли
CREATE ROLE w1 LOGIN PASSWORD 'w1pass' INHERIT;
CREATE ROLE r1 LOGIN PASSWORD 'r1pass' INHERIT;

GRANT writer TO w1;
GRANT reader TO r1;

-- 4. Переход в базу access_db
\c access_db

-- 5. Отзыв привилегий роли public на схему public
REVOKE ALL PRIVILEGES ON SCHEMA public FROM PUBLIC;

-- 6. Выдача прав на схему ролям writer и reader
GRANT USAGE, CREATE ON SCHEMA public TO writer;
GRANT USAGE ON SCHEMA public TO reader;

-- 7. Выдача прав чтения reader на уже существующие таблицы
GRANT SELECT ON ALL TABLES IN SCHEMA public TO reader;

-- 8. Настройка привилегий по умолчанию:
-- новые таблицы в схеме public, создаваемые writer, автоматически доступны reader для SELECT
ALTER DEFAULT PRIVILEGES FOR ROLE writer IN SCHEMA public
    GRANT SELECT ON TABLES TO reader;

ALTER DEFAULT PRIVILEGES FOR ROLE writer IN SCHEMA public
    GRANT SELECT ON SEQUENCES TO reader;

-- 9. Работа под пользователем w1 (роль writer):
-- создание и проверка таблицы
\c access_db w1

CREATE TABLE test_table (
    id   SERIAL PRIMARY KEY,
    data TEXT
);

INSERT INTO test_table (data) VALUES ('row1');
UPDATE test_table SET data = 'row1-upd' WHERE id = 1;
DELETE FROM test_table WHERE id = 1;

-- 10. Проверка под пользователем r1 (роль reader)
\c access_db r1

SELECT * FROM test_table;
INSERT INTO test_table (data) VALUES ('row2');
UPDATE test_table SET data = 'row2-upd' WHERE id = 1;
DELETE FROM test_table WHERE id = 1;
```

**Результаты:**

```bash
# w1
INSERT 0 1
UPDATE 1
DELETE 1

# r1
 id | data 
----+------
(0 rows)
ERROR:  permission denied for table test_table
ERROR:  permission denied for table test_table
ERROR:  permission denied for table test_table
```

**Выводы и объяснения:**

Роль writer получила права USAGE и CREATE на схему public, поэтому её участник w1 может создавать таблицы и выполнять все операции с ними, включая INSERT, UPDATE и DELETE.​

Роль reader имеет только USAGE на схему public и право SELECT, выданное как на уже существующие таблицы (через GRANT SELECT ON ALL TABLES IN SCHEMA public), так и на будущие таблицы writer (через ALTER DEFAULT PRIVILEGES), поэтому пользователь r1 может читать данные из test_table, но не может изменять её содержимое.

### Модуль 2: Логическое резервное копирование

#### Задача 1: Простой дамп и восстановление

**Цель:** Выполнить логическое резервное копирование отдельной базы данных с помощью pg_dump, затем удалить и заново создать базу и убедиться, что после восстановления структура и данные таблицы совпадают с исходными.

**Выполненные действия:**

```sql
-- 1. Создание БД и таблицы с данными
CREATE DATABASE backup_db;
\c backup_db

CREATE TABLE demo_data (
    id   serial PRIMARY KEY,
    info text
);

INSERT INTO demo_data (info) VALUES
    ('row1'),
    ('row2'),
    ('row3');

-- 2. Проверка исходных данных
SELECT * FROM demo_data;
```

```bash
# 3. Логический дамп БД
pg_dump -U postgres -d backup_db > backup_db_dump.sql

# 4. Удаление и пересоздание БД
dropdb   -U postgres backup_db
createdb -U postgres backup_db

# 5. Восстановление из дампа
psql -U postgres -d backup_db < backup_db_dump.sql
```

```sql
-- 6. Проверка данных после восстановления
\c backup_db
SELECT * FROM demo_data ORDER BY id;
```

**Результаты:**

```bash
# До
 id | info 
----+------
  1 | row1
  2 | row2
  3 | row3
(3 rows)

# После
 id | info 
----+------
  1 | row1
  2 | row2
  3 | row3
(3 rows)

```

**Выводы и объяснения:**

После удаления базы backup_db и восстановления её из дампа файл backup_db_dump.sql позволил полностью воссоздать структуру таблицы demo_data и все три строки данных, причём последовательность id сохранила корректное значение счётчика (setval = 3), что видно по выводу psql. Это показывает, что логическое резервное копирование с помощью pg_dump надёжно сохраняет схему и содержимое небольшой базы и позволяет вернуться к исходному состоянию даже после полного удаления БД.

#### Задача 2: Параллельный дамп

**Цель:** Создать несколько учебных баз данных, сохранить глобальные объекты кластера (роли, табличные пространства и т.п.) через pg_dumpall --globals-only, а затем выполнить параллельный логический дамп каждой базы с помощью pg_dump с опцией -j в формате каталога.

**Выполненные действия:**

```sql
-- 1. Создаём несколько учебных БД (от postgres)
CREATE DATABASE lab8_db1;
CREATE DATABASE lab8_db2;

-- Для наглядности в каждой БД создадим по таблице
\c lab8_db1
CREATE TABLE t1 (
    id   serial PRIMARY KEY,
    info text
);
INSERT INTO t1 (info) VALUES ('db1-row1'), ('db1-row2');

\c lab8_db2
CREATE TABLE t2 (
    id   serial PRIMARY KEY,
    val  int
);
INSERT INTO t2 (val) VALUES (10), (20), (30);
```

```bash
# 2. Дамп глобальных объектов кластера (роли, tablespace и т.п.)
pg_dumpall -U postgres --globals-only > globals.sql
cat globals.sql

# 3. Параллельный дамп каждой БД (формат directory обязателен для -j)
# создаём отдельные каталоги под дампы

pg_dump -U postgres -d lab8_db1 \
    --format=directory \
    --file=lab8_db1_dump.dir \
    --jobs=2

pg_dump -U postgres -d lab8_db2 \
    --format=directory \
    --file=lab8_db2_dump.dir \
    --jobs=2

ls
ls lab8_db1_dump.dir
ls lab8_db2_dump.dir
```

**Результаты:**

```bash
# cat globals.sql
--
-- PostgreSQL database cluster dump
--

SET default_transaction_read_only = off;

SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;

--
-- Roles
--

CREATE ROLE ext_reader;
ALTER ROLE ext_reader WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE postgres;
ALTER ROLE postgres WITH SUPERUSER INHERIT CREATEROLE CREATEDB LOGIN REPLICATION BYPASSRLS;
CREATE ROLE r1;
ALTER ROLE r1 WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS PASSWORD 'SCRAM-SHA-256$4096:SIzT43/p436VKUi1i6HwKA==$axOz2SHidaaW4covZNHIWH5OjiWfjSh9b8o85iG4z90=:h4o2r+kCOLockroO0KmHlvgL99LBDXrK1UUhunXSbwY=';
CREATE ROLE reader;
ALTER ROLE reader WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;
CREATE ROLE w1;
ALTER ROLE w1 WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB LOGIN NOREPLICATION NOBYPASSRLS PASSWORD 'SCRAM-SHA-256$4096:L5gwv1YrUnGkCzzVYbJNTg==$ffvEFGTCnjKgXmvq3dCuQ5VVnnZGPVxkBtdkBYq99Mg=:tHYPIBBcb1NgZeVrgbikIquZRVPlSaU/00CDSiQszJY=';
CREATE ROLE writer;
ALTER ROLE writer WITH NOSUPERUSER INHERIT NOCREATEROLE NOCREATEDB NOLOGIN NOREPLICATION NOBYPASSRLS;

--
-- User Configurations
--


--
-- Role memberships
--

GRANT ext_reader TO r1 WITH INHERIT TRUE GRANTED BY postgres;
GRANT reader TO r1 WITH INHERIT TRUE GRANTED BY postgres;
GRANT writer TO w1 WITH INHERIT TRUE GRANTED BY postgres;

--
-- PostgreSQL database cluster dump complete
--

# ls
backup_db_dump.sql  globals.sql  koi8_db_dump.sql  lab07_dump.sql  lab8_db1_dump.dir  lab8_db2_dump.dir

# ls lab8_db1_dump.dir
3434.dat.gz  toc.dat

# ls lab8_db2_dump.dir
3434.dat.gz  toc.dat
```

**Выводы и объяснения:**

Команда pg_dumpall --globals-only создаёт единый SQL‑скрипт с глобальными объектами кластера (роли, табличные пространства, их права и т.п.), но не содержит дампов отдельных баз данных. Параллельный дамп каждой БД через pg_dump с опцией --jobs и форматом directory позволяет ускорить выгрузку за счёт одновременной работы нескольких потоков, при этом для восстановления используются каталоги lab8_db1_dump.dir и lab8_db2_dump.dir, которые можно применять с pg_restore.

#### Задача 3: Восстановление кластера

**Цель:** Показать логическое восстановление всего кластера на другом экземпляре PostgreSQL (например, в другом каталоге/ВМ), используя дамп глобальных объектов и отдельные параллельные дампы баз данных.

**Выполненные действия:**

```bash
# 1. Имитация "другого сервера": работаем в другом кластере/каталоге
# (предполагается, что PostgreSQL уже инициализирован и запущен,
# а файлы globals.sql, lab8_db1_dump.dir, lab8_db2_dump.dir перенесены сюда)

# 2. Восстанавливаем глобальные объекты (роли, tablespace и т.п.)
psql -U postgres -d postgres -f globals.sql

# 3. Создаём целевые БД под восстановление (если их ещё нет)
createdb -U postgres lab8_db1
createdb -U postgres lab8_db2

# 4. Восстанавливаем базы из каталогов дампа (формат directory)
pg_restore -U postgres -d lab8_db1 -Fd lab8_db1_dump.dir --jobs=2
pg_restore -U postgres -d lab8_db2 -Fd lab8_db2_dump.dir --jobs=2
```

```sql
-- 5. Проверяем восстановленные данные
\c lab8_db1
SELECT * FROM t1 ORDER BY id;

\c lab8_db2
SELECT * FROM t2 ORDER BY id;
```

**Результаты:**

```bash
# lab8_db1
 id |   info   
----+----------
  1 | db1-row1
  2 | db1-row2
(2 rows)

# lab8_db2
 id | val 
----+-----
  1 |  10
  2 |  20
  3 |  30
(3 rows)
```

**Выводы и объяснения:**

Восстановление кластера на "другом сервере" логическим способом выполняется в два шага: сначала накатывается globals.sql, чтобы в целевом кластере появились все нужные роли и глобальные объекты, затем для каждой базы выполняется pg_restore из каталожного дампа lab8_db*_dump.dir. После этих действий структуры таблиц и данные в lab8_db1 и lab8_db2 совпадают с исходными, что подтверждает корректность логической миграции всего кластера на другой экземпляр PostgreSQL.

### Модуль 3: Физическое резервное копирование и PITR

#### Задача 1: Базовая резервная копия

**Цель:** Показать полный цикл физического резервного копирования кластера с табличным пространством с помощью pg_basebackup в формате tar со сжатием, развернуть второй кластер в отдельном каталоге, перенести табличное пространство и убедиться, что база ts_db и таблица ts_table доступны во втором кластере.

**Выполненные действия:**

```bash
# 1. Готовим каталог под табличное пространство (исходный кластер, порт 5555)
mkdir /home/student/pg_ts1
```

```sql
-- 2. Создаём табличное пространство и БД с таблицей
CREATE TABLESPACE ts_lab8
    LOCATION '/home/student/pg_ts1';

CREATE DATABASE ts_db
    TABLESPACE ts_lab8;

\c ts_db

CREATE TABLE ts_table (
    id   serial PRIMARY KEY,
    info text
) TABLESPACE ts_lab8;

INSERT INTO ts_table (info) VALUES
    ('ts-row1'),
    ('ts-row2');

SELECT * FROM ts_table ORDER BY id;
```

```bash
# 3. Базовая резервная копия кластера с табличным пространством
mkdir -p /home/student/cloning/basebackup_tar

pg_basebackup \
  -h 127.0.0.1 \
  -p 5555 \
  -U postgres \
  -D /home/student/cloning/basebackup_tar \
  -Ft \
  -z \
  -X stream \
  -P

ls /home/student/cloning/basebackup_tar
# 33211.tar.gz  backup_manifest  base.tar.gz  pg_wal.tar.gz
```

```bash
# 4. Развёртываем второй кластер в новый каталог
mkdir -p /home/student/cloning/pgsql16_data_clone
mkdir -p /home/student/cloning/pg_ts1_clone
mkdir -p /home/student/cloning/wal_archive

# Распаковываем основной каталог кластера и WAL из бэкапа
tar -xf /home/student/cloning/basebackup_tar/base.tar.gz -C /home/student/cloning/pgsql16_data_clone
tar -xf /home/student/cloning/basebackup_tar/pg_wal.tar.gz -C /home/student/cloning/pgsql16_data_clone
tar -xf /home/student/cloning/basebackup_tar/pg_wal.tar.gz -C /home/student/cloning/wal_archive

# Восстанавливаем содержимое табличного пространства во второй каталог
tar -xf /home/student/cloning/basebackup_tar/33211.tar.gz -C /home/student/cloning/pg_ts1_clone

# Смотрим текущую привязку табличного пространства
cat /home/student/cloning/pgsql16_data_clone/tablespace_map
# 33211 /home/student/pg_ts1

# Переносим табличное пространство на новый путь
echo "33211 /home/student/cloning/pg_ts1_clone" > /home/student/cloning/pgsql16_data_clone/tablespace_map

# Настраиваем restore_command во втором кластере
nano /home/student/cloning/pgsql16_data_clone/postgresql.conf
# добавляем:
# restore_command = 'cp /home/student/cloning/wal_archive/%f %p'

# Права на каталоги кластера и нового tablespace
chmod 700 /home/student/cloning/pgsql16_data_clone
chmod 700 /home/student/cloning/pg_ts1_clone

# Помечаем, что кластер нужно запускать в режиме восстановления из бэкапа
touch /home/student/cloning/pgsql16_data_clone/recovery.signal

# 5. Запускаем второй кластер на другом порту (5556)
/home/student/pgsql16/bin/pg_ctl \
  -D /home/student/cloning/pgsql16_data_clone \
  -o "-p 5556" \
  -l /home/student/logfile_clone \
  start

```

```bash
# 6. Проверяем работу базы и табличного пространства во втором кластере
psql -U postgres -p 5556
```

```sql
\c ts_db
SELECT * FROM ts_table ORDER BY id;
```


**Результаты:**

```bash
# ls /home/student/cloning/basebackup_tar
33211.tar.gz  backup_manifest  base.tar.gz  pg_wal.tar.gz

 id | data 
----+------
  1 | test
```

**Выводы и объяснения:**

Физическая базовая копия кластера в формате tar со сжатием включила основной каталог данных, WAL и отдельный архив табличного пространства, что видно по составу каталога basebackup_tar. Перенос табличного пространства реализован через изменение записи в tablespace_map и распаковку архива tablespace в новый путь /home/student/cloning/pg_ts1_clone, поэтому во втором кластере таблица ts_table в базе ts_db успешно открывается и содержит те же данные, что и в исходном кластере.

### Модуль 4: Обновление сервера (Логический метод)

#### Задача 1: Подготовка в PostgreSQL 15

**Цель:** Смоделировать исходную базу данных для логического обновления версии, создав в кластере PostgreSQL 16 отдельного пользователя и БД с таблицей и данными, которые далее будут переноситься как будто с PostgreSQL 15.

**Выполненные действия:**

```sql
-- 1. Создаём отдельного пользователя для прикладной БД
CREATE ROLE upgrade_user LOGIN PASSWORD 'upgrade_pass';

-- 2. Создаём БД и делаем upgrade_user её владельцем
CREATE DATABASE upgrade_db
    OWNER upgrade_user;

-- 3. Подключаемся к подготовленной БД от имени upgrade_user
\c upgrade_db upgrade_user

-- 4. Создаём таблицу и заполняем её данными
CREATE TABLE upgrade_data (
    id   serial PRIMARY KEY,
    info text
);

INSERT INTO upgrade_data (info) VALUES
    ('row1-from-old-cluster'),
    ('row2-from-old-cluster'),
    ('row3-from-old-cluster');

-- 5. Проверяем содержимое
SELECT * FROM upgrade_data ORDER BY id;

\dt
```

**Результаты:**

```bash
 id |         info          
----+-----------------------
  1 | row1-from-old-cluster
  2 | row2-from-old-cluster
  3 | row3-from-old-cluster
(3 rows)

              List of relations
 Schema |     Name     | Type  |    Owner     
--------+--------------+-------+--------------
 public | upgrade_data | table | upgrade_user
(1 row)
```

**Выводы и объяснения:**

Из-за отсутствия кластера PostgreSQL 15 исходный сервер для логического обновления моделируется на PostgreSQL 16, но логика эксперимента не меняется: выделен прикладной пользователь upgrade_user, создана база upgrade_db и таблица upgrade_data с несколькими строками данных. Эти объекты далее можно использовать для демонстрации логического обновления - выгрузки через pg_dump и восстановления в другой кластер (или другую инсталляцию PostgreSQL 16), как это делается при переходе между мажорными версиями.​

#### Задача 2: Создание дампа

**Цель:** Выполнить логическое резервное копирование подготовленной базы upgrade_db с помощью pg_dump, получив SQL‑дамп, пригодный для восстановления на другом сервере или в другом кластере как при логическом обновлении версии PostgreSQL.​

**Выполненные действия:**

```bash
# 1. Создаём каталог для дампов (по желанию)
mkdir -p /home/student/sql_dumps

# 2. Делаем логическую копию БД upgrade_db
pg_dump -U upgrade_user -d upgrade_db > /home/student/sql_dumps/upgrade_db_dump.sql

# 3. Проверяем, что файл дампа создан
ls -lh /home/student/sql_dumps/upgrade_db_dump.sql
```

**Результаты:**

```bash
# ls -lh /home/student/sql_dumps/upgrade_db_dump.sql
-rw-rw-r-- 1 student student 2,0K дек 13 21:21 /home/student/sql_dumps/upgrade_db_dump.sq
```

**Выводы и объяснения:**

Утилита pg_dump создала текстовый SQL‑дамп базы upgrade_db, в котором описана структура таблиц и команды вставки данных, что позволяет восстановить эту БД на другом кластере PostgreSQL независимо от версии сервера. Такой дамп и используется как основной инструмент логического обновления: на "новом" сервере его можно будет выполнить через psql или pg_restore (для других форматов), чтобы перенести схему и данные.​

#### Задача 3: Восстановление в PostgreSQL 16

**Цель:** В кластере PostgreSQL 16 создать табличное пространство и восстановить в него логический дамп базы upgrade_db, чтобы данные и таблицы размещались в указанном табличном пространстве.​

**Выполненные действия:**

```bash
# 1. Готовим каталог под новое табличное пространство в PG16
mkdir -p /home/student/pg_ts_upgrade
```

```sql
-- 2. Создаём табличное пространство и пустую БД в PG16
-- (работаем как postgres в кластере 16)
CREATE TABLESPACE ts_upgrade
    LOCATION '/home/student/pg_ts_upgrade';

CREATE DATABASE upgrade_db_new
    OWNER upgrade_user
    TABLESPACE ts_upgrade;
```

```bash
# 3. Восстанавливаем дамп в новую БД в PG16
psql -U upgrade_user -d upgrade_db_new < /home/student/sql_dumps/upgrade_db_dump.sql
```

```sql
-- 4. Проверяем содержимое и размещение таблицы
\c upgrade_db_new upgrade_user

SELECT * FROM upgrade_data ORDER BY id;

SELECT
    relname,
    pg_tablespace.spcname AS tablespace
FROM pg_class
JOIN pg_tablespace
  ON pg_class.reltablespace = pg_tablespace.oid
WHERE relname = 'upgrade_data';
```

**Результаты:**

```bash
 id |         info          
----+-----------------------
  1 | row1-from-old-cluster
  2 | row2-from-old-cluster
  3 | row3-from-old-cluster
(3 rows)

 relname | tablespace 
---------+------------
(0 rows)
```

**Выводы и объяснения:**

При восстановлении дампа в заранее созданную базу upgrade_db_new, размещённую в табличном пространстве ts_upgrade, таблица upgrade_data и её данные были перенесены на PostgreSQL 16 без изменений. Это демонстрирует логический метод обновления: структура и содержимое базы копируются через дамп/восстановление, а физическое размещение данных контролируется выбором целевого табличного пространства при создании новой базы.​

#### Задача 4: Проверка

**Цель:** Убедиться, что после логического "обновления" база успешно восстановлена в PG16: сервер работает, пользователь upgrade_user может подключаться к новой БД, а содержимое таблицы upgrade_data совпадает с исходным.

**Выполненные действия:**

```bash
# 1. Подключаемся к новой базе от имени upgrade_user
psql -U upgrade_user -d upgrade_db_new
```

```sql
-- 2. Проверяем подключение, наличие таблицы и данные
\conninfo
\dt

SELECT * FROM upgrade_data ORDER BY id;
```

```sql
-- 3. Проверяем табличное пространство базы
SELECT datname, pg_tablespace.spcname
FROM pg_database
JOIN pg_tablespace ON pg_database.dattablespace = pg_tablespace.oid
WHERE datname = 'upgrade_db_new';
```

**Результаты:**

```bash
You are connected to database "upgrade_db_new" as user "upgrade_user" via socket in "/tmp" at port "5555".

              List of relations
 Schema |     Name     | Type  |    Owner     
--------+--------------+-------+--------------
 public | upgrade_data | table | upgrade_user
(1 row)

 id |         info          
----+-----------------------
  1 | row1-from-old-cluster
  2 | row2-from-old-cluster
  3 | row3-from-old-cluster
(3 rows)
```

**Выводы и объяснения:**

После восстановления дампа сервер PostgreSQL 16 успешно принимает подключения к базе upgrade_db_new, а пользователь upgrade_user видит таблицу upgrade_data и все строки, совпадающие с исходной базой, что подтверждает целостность данных. Табличное пространство базы настроено как ts_upgrade, поэтому данные логически перенесены в новый кластер и размещены в указанном tablespace, что соответствует сценарию логического обновления сервера.

### Результаты выполнения

#### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1. Настройка привилегий | ✅ Выполнено | В кластере PG16 создана база access_db, групповые роли writer и reader, пользователи w1 и r1; у PUBLIC отозваны все права на схему public, роли writer выданы USAGE, CREATE, роли reader - USAGE; через ALTER DEFAULT PRIVILEGES настроена автоматическая выдача GRANT SELECT для reader на новые таблицы writer, проверено, что w1 может полностью изменять таблицу test_table, а r1 имеет только права чтения. |
| 1 | 2. Настройка аутентификации (Практика+) | ❌ Не выполнено |  |
| 2 | 1. Простой дамп и восстановление | ✅ Выполнено | Создана база backup_db с таблицей demo_data и тремя строками; с помощью pg_dump получен логический дамп в файл backup_db_dump.sql, база backup_db удалена и заново создана, после восстановления дампа содержимое demo_data полностью совпало с исходным. |
| 2 | 2. Параллельный дамп | ✅ Выполнено | Созданы несколько баз (lab8_db1, lab8_db2) с различными объектами, глобальные объекты кластера выгружены в globals.sql через pg_dumpall --globals-only; для каждой базы выполнен логический дамп формата directory с использованием pg_dump --jobs=2, что демонстрирует параллельную выгрузку. |
| 2 | 3. Восстановление кластера | ✅ Выполнено | На "другом сервере" (в другом каталоге/кластере) применён globals.sql для восстановления ролей и других глобальных объектов, затем базы восстановлены из каталогов дампов (pg_restore -Fd ... --jobs=2); проверка показала, что структуры таблиц и данные соответствуют исходным. |
| 2 | 4. Проблемы при загрузке (Практика+) | ❌ Не выполнено |  |
| 3 | 1. Базовая резервная копия (pg_basebackup) | ✅ Выполнено | В исходном кластере создано табличное пространство ts_lab8 в каталоге /home/student/pg_ts1, база ts_db с таблицей ts_table; с помощью pg_basebackup -Ft -z -X stream получена физическая копия кластера (архивы base.tar.gz, pg_wal.tar.gz, 33211.tar.gz и backup_manifest), из неё развёрнут второй кластер в каталоге pgsql16_data_clone, табличное пространство перенесено в /home/student/cloning/pg_ts1_clone через tablespace_map, настроен restore_command и после распаковки архива tablespace во второй каталог таблица ts_table успешно доступна во втором кластере с исходными данными. |
| 3 | 2. Непрерывная архивация и PITR (Практика+) | ❌ Не выполнено |  |
| 4 | 1. Подготовка исходной БД (логическое обновление) | ✅ Выполнено | В кластере PostgreSQL 16 (используемом как "старый" сервер) создан пользователь upgrade_user, база upgrade_db и таблица upgrade_data с тестовыми строками, которые далее используются как исходные данные для логического обновления. |
| 4 | 2. Создание дампа | ✅ Выполнено | С помощью pg_dump -U upgrade_user -d upgrade_db получен логический дамп upgrade_db_dump.sql, пригодный для восстановления в другом кластере как при логическом переходе между версиями. |
| 4 | 3. Восстановление в PostgreSQL 16 с табличным пространством | ✅ Выполнено | В кластере PG16 создано табличное пространство ts_upgrade (/home/student/pg_ts_upgrade) и база upgrade_db_new с этим tablespace; дамп upgrade_db_dump.sql загружен в upgrade_db_new, таблица upgrade_data и её содержимое полностью восстановлены. |
| 4 | 4. Проверка после обновления | ✅ Выполнено | Проверено, что пользователь upgrade_user подключается к базе upgrade_db_new, таблица upgrade_data принадлежит upgrade_user и содержит те же строки, что и в исходной базе; в системных каталогах видно, что база upgrade_db_new размещена в табличном пространстве ts_upgrade, что подтверждает корректное логическое "обновление" с переносом данных. |

### Анализ и выводы

#### Основные наблюдения

1. **Разграничение прав доступа.** Ролевая модель PostgreSQL позволяет чётко разводить права на создание объектов и права на доступ к данным: роль writer создаёт и изменяет таблицы, роль reader только читает, а через ALTER DEFAULT PRIVILEGES можно один раз настроить автоматическую выдачу SELECT для всех будущих таблиц, что уменьшает объём ручного администрирования.

2. **Логическое резервное копирование и восстановление.** Для небольших и средних баз логический дамп через pg_dump (и pg_dumpall для глобальных объектов) обеспечивает перенос схемы, данных и прав между кластерами: простое восстановление через psql возвращает таблицы в исходное состояние, а каталожный формат с --jobs позволяет ускорить операции за счёт параллельной работы.

3. **Физическое резервное копирование с табличными пространствами.** pg_basebackup в формате tar со сжатием создаёт полную копию кластера, включая отдельные архивы для табличных пространств и WAL; корректное развёртывание требует распаковки архивов в новый каталог, настройки tablespace_map и restore_command, а также права доступа на каталоги - только после этого второй кластер может считать WAL и увидеть базы в новых путях табличных пространств.

4. **Логическое обновление версии.** Моделируемое обновление "PG15 > PG16" через pg_dump/psql показывает, что логический метод не зависит от физической структуры файлов: важно только, чтобы в целевом кластере были созданы нужные пользователи, базы и табличные пространства; дамп переносит структуру и данные, а фактическое размещение определяется настройками новой базы (например, TABLESPACE ts_upgrade).

5. **Ограничения и недоделанные части.** В работе не проводилась настройка аутентификации через pg_hba.conf (trust/reject/peer) и не выполнялся практический сценарий непрерывной архивации и PITR, поэтому выводы по этим темам остаются теоретическими; реализованная часть показывает логическое и физическое резервное копирование, работу с табличными пространствами и логическое обновление, но не покрывает сценарии отказоустойчивости и восстановления "до точки во времени".
