# Отчет по лабораторной работе №3
# Модель многопользовательского доступа: MVCC

## Сведения о студенте

**Дата:** 01.11.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович  

## Цель работы

Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL. Получить практические навыки наблюдения за работой MVCC, анализа версий строк, снимков данных и уровней изоляции транзакций. Освоить использование расширений и системных представлений для исследования внутренней структуры данных.

## Теоретическая часть

### Изученные концепции

- **MVCC (Multiversion Concurrency Control):** механизм управления конкурентным доступом, создающий новые версии строк при изменениях

- **Уровни изоляции транзакций:** определяют видимость данных и допустимые аномалии параллелизма

- **Системные поля версий строк:** xmin, xmax, ctid для отслеживания жизненного цикла строк

- **Снимки данных (Snapshot):** набор идентификаторов транзакций, определяющих видимость данных

### Ключевые термины

- **xmin:** Идентификатор транзакции, создавшей версию строки

- **xmax:** Идентификатор транзакции, удалившей или заблокировавшей строку для обновления

- **ctid:** Физическое расположение версии строки в таблице (номер страницы и позиция)

- **Read Committed:** Уровень изоляции по умолчанию, видит только зафиксированные данные

- **Repeatable Read:** Уровень изоляции, гарантирующий повторяемость чтения

## Практическая часть

### Модуль 1: Уровни изоляции и аномалии

#### Задача 1: Read Committed vs Удаление

**Цель:** Продемонстрировать поведение уровня изоляции Read Committed при удалении строк в параллельной транзакции.

**Выполненные действия:**

```sql
-- Сеанс 1
-- Создаем таблицу
CREATE TABLE iso_test (id INT, data TEXT);
INSERT INTO iso_test VALUES (1, 'test');

-- Начинаем транзакцию с READ COMMITTED (по умолчанию)
BEGIN;
SELECT * FROM iso_test;
```

```sql
-- Сеанс 2
-- Удаляем строку и фиксируем
DELETE FROM iso_test;
COMMIT;
```

```sql
-- Сеанс 1
-- После выполнения DELETE в сеансе 2:
SELECT * FROM iso_test;
COMMIT;
```

**Результаты:**

```bash
# Первый SELECT в сеансе 1:
 id | data 
----+------
  1 | test
(1 row)

# Второй SELECT в сеансе 1 (после DELETE в сеансе 2):
 id | data 
----+------
(0 rows)
```

**Выводы и объяснения:** На уровне изоляции READ COMMITTED каждый запрос в транзакции видит данные, зафиксированные на момент начала этого запроса. При первом SELECT строка существует. После выполнения DELETE и COMMIT в сеансе 2, второй SELECT в сеансе 1 не видит строку, так как она уже удалена и изменения зафиксированы.

#### Задача 2: Repeatable Read vs Удаление

**Цель:** Продемонстрировать разницу между уровнями изоляции при удалении строк.

**Выполненные действия:**

```sql
-- Сеанс 1
TRUNCATE iso_test;
INSERT INTO iso_test VALUES (1, 'test');

BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM iso_test;
```

```sql
-- Сеанс 2
DELETE FROM iso_test;
COMMIT;
```

```sql
-- Сеанс 1
SELECT * FROM iso_test;
COMMIT;
```

**Результаты:**

```bash
# Первый SELECT в сеансе 1:
 id | data 
----+------
  1 | test
(1 row)

# Второй SELECT в сеансе 1 (после DELETE в сеансе 2):
 id | data 
----+------
  1 | test
(1 row)
```

**Выводы и объяснения:** На уровне REPEATABLE READ снимок данных для таблицы создается при первом обращении к ней в транзакции. После удаления и фиксации в сеансе 2, сеанс 1 продолжает видеть строку, так как использует снимок на момент первого SELECT. Это предотвращает аномалию "неповторяемое чтение".

#### Задача 3: Создание таблицы в транзакции

**Цель:** Исследовать видимость DDL-операций в параллельных транзакциях.

##### Вариант с COMMIT:

**Выполненные действия:**

```sql
-- Сеанс 1
BEGIN;
CREATE TABLE new_table (id INT);
INSERT INTO new_table VALUES (1);
```

```sql
-- Сеанс 2
SELECT * FROM new_table;
```

```sql
-- Сеанс 1
COMMIT;
```

```sql
-- Сеанс 2
SELECT * FROM new_table;
```

**Результаты:**

```bash
# SELECT в сеансе 2 до COMMIT:
ERROR:  relation "new_table" does not exist
LINE 1: SELECT * FROM new_table;

# SELECT в сеансе 2 после COMMIT:
 id 
----
  1
(1 row)
```

**Выводы и объяснения:** DDL-операции (CREATE TABLE) транзакционны. До фиксации транзакции в сеансе 1, таблица не видна в других сеансах. После фиксации - становится доступной.

##### Вариант с ROLLBACK:

**Выполненные действия:**

```sql
-- Сеанс 1
BEGIN;
CREATE TABLE new_table2 (id INT);
INSERT INTO new_table2 VALUES (1);
ROLLBACK;
```

```sql
-- Сеанс 2
SELECT * FROM new_table2;
```

**Результаты:**

```bash
ERROR:  relation "new_table2" does not exist
LINE 1: SELECT * FROM new_table2;
```

**Выводы и объяснения:** При откате транзакции все DDL-операции отменяются, таблица не создается.

#### Задача 4: Блокировка DDL

**Цель:** Исследовать блокировки при выполнении DDL-операций.

**Выполненные действия:**

```sql
-- Сеанс 1
BEGIN;
SELECT * FROM iso_test;
-- Транзакция активна
```

```sql
-- Сеанс 2
DROP TABLE iso_test;
-- Команда "висит" ожидая завершения транзакции в сеансе 1
```

**Результаты:** Команда DROP TABLE в сеансе 2 блокируется до завершения транзакции в сеансе 1.

**Выводы и объяснения:** Команда DROP TABLE требует эксклюзивной блокировки на таблицу. SELECT в сеансе 1 удерживает блокировку на чтение (AccessShareLock). DDL-операции блокируются, пока есть активные операции чтения. Это предотвращает удаление таблицы, которая используется в других транзакциях.

### Модуль 2: Фантомное чтение и снимки

#### Задача 1: Фантомное чтение (Read Committed)

**Цель:** Продемонстрировать фантомное чтение на уровне Read Committed.

**Выполненные действия:**

```sql
-- Сеанс 1
CREATE TABLE phantom_test (id INT);

BEGIN;
SELECT * FROM phantom_test;
```

```sql
-- Сеанс 2
INSERT INTO phantom_test VALUES (1);
COMMIT;
```

```sql
-- Сеанс 1
SELECT * FROM phantom_test;
COMMIT;
```

**Результаты:**

```bash
# Первый SELECT в сеансе 1:
 id 
----
(0 rows)

# Второй SELECT в сеансе 1:
 id 
----
  1
(1 row)
```

**Выводы и объяснения:** На уровне READ COMMITTED наблюдается фантомное чтение: вторая транзакция вставила строку, и она стала видна в повторном чтении первой транзакции.

#### Задача 2: Невидимость удалений (Repeatable Read)

**Цель:** Исследовать видимость удаленных строк на уровне Repeatable Read.

##### Вариант 1: SELECT выполняется ДО удаления (неправильный подход):

**Выполненные действия:**

```sql
-- Подготовка
TRUNCATE phantom_test;
INSERT INTO phantom_test VALUES (1), (2), (3);
```

```sql
-- Сеанс 1
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- Пока без запросов к phantom_test
```

```sql
-- Сеанс 2
DELETE FROM phantom_test;
COMMIT;
```

```sql
-- Сеанс 1
SELECT * FROM phantom_test;
COMMIT;
```

**Результаты:**

```bash
# SELECT в сеансе 1 (после DELETE в сеансе 2):
 id 
----
(0 rows)
```

##### Вариант 2: SELECT выполняется ДО удаления (правильный подход):

**Выполненные действия:**

```sql
-- Подготовка
TRUNCATE phantom_test;
INSERT INTO phantom_test VALUES (1), (2), (3);
```

```sql
-- Сеанс 1
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM phantom_test; -- Снимок для phantom_test зафиксирован!
```

```sql
-- Сеанс 2
DELETE FROM phantom_test;
COMMIT;
```

```sql
-- Сеанс 1
SELECT * FROM phantom_test; -- Повторный запрос
COMMIT;
```

**Результаты:**

```bash
# Первый SELECT в сеансе 1 (ДО удаления в сеансе 2):
 id 
----
  1
  2
  3
(3 rows)

# Второй SELECT в сеансе 1 (ПОСЛЕ удаления в сеансе 2):
 id 
----
  1
  2
  3
(3 rows)
```

**Выводы и объяснения:** На уровне REPEATABLE READ снимок данных для таблицы создается при первом обращении к ней в транзакции. Если SELECT выполняется после удаления в другой транзакции, он видит уже удаленные данные. Если SELECT выполняется до удаления - он фиксирует снимок и продолжает видеть строки даже после их удаления.

#### Задача 3: Транзакционность DDL

**Цель:** Убедиться, что DROP TABLE является транзакционной операцией.

**Выполненные действия:**

```sql
CREATE TABLE test_ddl (id INT);
INSERT INTO test_ddl VALUES (1);

BEGIN;
DROP TABLE test_ddl;
SELECT * FROM test_ddl;  -- Ошибка - таблица удалена
ROLLBACK;

SELECT * FROM test_ddl;  -- Таблица существует
```

**Результаты:**

```bash
# После удаления таблицы:
ERROR:  relation "test_ddl" does not exist
LINE 1: SELECT * FROM test_ddl;

# После ROLLBACK:
 id 
----
  1
(1 row)
```

**Выводы и объяснения:** DROP TABLE полностью транзакционен и может быть откачен. После ROLLBACK таблица и данные восстанавливаются.

### Модуль 3: Версии строк и pageinspect

#### Задача 1: Жизненный цикл строки

**Цель:** Изучить создание версий строк при обновлениях и удалении.

**Выполненные действия:**

```sql
-- Создаем таблицу и расширение
CREATE TABLE version_test (id INT);
CREATE EXTENSION IF NOT EXISTS pageinspect;

-- Вставляем строку
INSERT INTO version_test VALUES (1);

-- Обновляем два раза
UPDATE version_test SET id = 2;
UPDATE version_test SET id = 3;

-- Удаляем строку
DELETE FROM version_test;

-- Анализируем страницы
SELECT lp, t_xmin, t_xmax, t_ctid, t_data 
FROM heap_page_items(get_raw_page('version_test', 0));
```

**Результаты:**

```bash
 lp | t_xmin | t_xmax | t_ctid |   t_data   
----+--------+--------+--------+------------
  1 |    816 |    817 | (0,2)  | \x01000000
  2 |    817 |    818 | (0,3)  | \x02000000
  3 |    818 |    819 | (0,3)  | \x03000000
(3 rows)
```

**Выводы и объяснения:**
Создано 3 версии строки:
- Версия 1 (lp=1): создана INSERT (xmin=816), помечена как удаленная первым UPDATE (xmax=817)
- Версия 2 (lp=2): создана первым UPDATE (xmin=817), удалена вторым UPDATE (xmax=818)
- Версия 3 (lp=3): создана вторым UPDATE (xmin=818), удалена DELETE (xmax=819)
Все версии остаются в таблице до выполнения VACUUM. Поле t_ctid указывает на следующую версию строки.

#### Задача 2: Анализ системной таблицы

**Цель:** Изучить структуру системных таблиц с помощью pageinspect.

**Выполненные действия:**

```sql
-- Находим страницу для pg_class
SELECT relname, relfilenode FROM pg_class WHERE relname = 'pg_class';

-- Используем pageinspect для анализа
SELECT lp, t_xmin, t_xmax, t_ctid 
FROM heap_page_items(get_raw_page('pg_class', 0))
LIMIT 10;

-- Подсчет актуальных версий
SELECT COUNT(*) as visible_rows
FROM heap_page_items(get_raw_page('pg_class', 0))
WHERE t_xmax = 0 OR t_xmax IS NULL;
```

**Результаты:**

```bash
 relname  | relfilenode 
----------+-------------
 pg_class |           0
(1 row)

 lp | t_xmin | t_xmax | t_ctid 
----+--------+--------+--------
  1 |        |        | 
  2 |    764 |      0 | (0,2)
  3 |        |        | 
  4 |        |        | 
  5 |        |        | 
  6 |        |        | 
  7 |        |        | 
  8 |        |        | 
  9 |        |        | 
 10 |        |        | 
(10 rows)

 visible_rows 
--------------
           47
(1 row)
```

**Выводы и объяснения:** Таблица pg_class, как и пользовательские таблицы, использует MVCC. Большинство строк имеют xmax=0, что означает "не удалена". Пустые строки (без t_xmin) представляют собой свободное пространство на странице. VACUUM периодически очищает старые версии.

#### Задача 3: ON_ERROR_ROLLBACK

**Цель:** Исследовать режим ON_ERROR_ROLLBACK в psql.

**Выполненные действия:**

```sql
-- Включаем режим
\set ON_ERROR_ROLLBACK on

-- Создаем ситуацию с ошибкой
BEGIN;
INSERT INTO version_test VALUES (1);
SELECT * FROM non_existent_table;  -- Ошибка
INSERT INTO version_test VALUES (2);  -- Выполнится
COMMIT;

-- Проверяем
SELECT * FROM version_test;
```

**Результаты:**

```bash
ERROR:  relation "non_existent_table" does not exist
LINE 1: SELECT * FROM non_existent_table;
INSERT 0 1
COMMIT

# После COMMIT:
 id 
----
  1
  2
(2 rows)
```

**Выводы и объяснения:** С включенным ON_ERROR_ROLLBACK psql автоматически использует SAVEPOINT перед каждой командой. При ошибке происходит откат к последнему SAVEPOINT, а не всей транзакции. Это позволяет продолжать работу в транзакции после ошибок.

### Модуль 4: Снимки данных (Snapshots)

#### Задача 1: Видимость удаленной строки

**Цель:** Воспроизвести ситуацию, когда одна транзакция видит строку, а другая, начавшаяся позже, - уже нет.

**Выполненные действия:**

```sql
-- Подготовка
DROP TABLE IF EXISTS snapshot_test;
CREATE TABLE snapshot_test (id INT);
INSERT INTO snapshot_test VALUES (1);
```

```sql
-- Транзакция A (начинается и сразу читает данные)
BEGIN;
SELECT txid_current() as txid_a;
SELECT pg_current_snapshot() as snapshot_a_before;
SELECT * FROM snapshot_test;  -- Читаем до удаления
```

```sql
-- Транзакция B (удаляет строку)
BEGIN;
SELECT txid_current() as txid_b;
DELETE FROM snapshot_test;
COMMIT;
```

```sql
-- Транзакция C (начинается после удаления)
BEGIN;
SELECT txid_current() as txid_c;
SELECT pg_current_snapshot() as snapshot_c;
SELECT * FROM snapshot_test;
SELECT pg_snapshot_xip(pg_current_snapshot());
COMMIT;
```

```sql
-- Транзакция A (продолжение)
SELECT pg_current_snapshot() as snapshot_a_after;
SELECT * FROM snapshot_test;  -- Проверяем видимость после удаления
COMMIT;
```

**Результаты:**

```bash
# Транзакция A (начало):
 txid_a 
--------
    860
(1 row)

 snapshot_a_before 
-------------------
 860:860:
(1 row)

 id 
----
  1

# Транзакция B:
 txid_b 
--------
    861
(1 row)

# Транзакция C:
 txid_c 
--------
    862
(1 row)

 snapshot_c  
-------------
 860:862:860
(1 row)

 id 
----
(0 rows)

 pg_snapshot_xip 
-----------------
             860
(1 row)

# Транзакция A (после удаления):
 snapshot_a_after 
------------------
 860:863:
(1 row)

 id 
----
(0 rows)
```

**Выводы и объяснения:** На уровне READ COMMITTED каждая команда в транзакции видит данные, зафиксированные на момент начала этой команды. Транзакция A при первом SELECT видит строку (id=1), но после удаления в транзакции B и фиксации изменений, второй SELECT в транзакции A использует новый снимок и уже не видит строку. Это демонстрирует фундаментальное различие между READ COMMITTED (видит последние зафиксированные данные) и REPEATABLE READ (сохраняет снимок на момент первого обращения к таблице).

#### Задача 2: Снимки в функциях

**Цель:** Исследовать использование снимков в функциях разных категорий.

**Выполненные действия:**

```sql
-- Подготовка
CREATE TABLE func_test (id INT);
INSERT INTO func_test VALUES (1);
```

```sql
-- STABLE функция
CREATE OR REPLACE FUNCTION get_data_stable() 
RETURNS SETOF func_test
STABLE AS $$
BEGIN
    RETURN QUERY SELECT * FROM func_test;
END;
$$ LANGUAGE plpgsql;
```

```sql
-- VOLATILE функция  
CREATE OR REPLACE FUNCTION get_data_volatile()
RETURNS SETOF func_test
VOLATILE AS $$
BEGIN
    RETURN QUERY SELECT * FROM func_test;
END;
$$ LANGUAGE plpgsql;
```

```sql
-- Тест 1: STABLE функция
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM get_data_stable();
COMMIT;
```

```sql
-- В другом сеансе:
UPDATE func_test SET id = 2;
```

```sql
-- Снова в первом сеансе:
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM get_data_stable(); -- Должно вернуть 2
COMMIT;

-- Тест 2: VOLATILE функция
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM get_data_volatile();
COMMIT;
```

```sql
-- В другом сеансе:
UPDATE func_test SET id = 3;

-- Снова в первом сеансе:
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM get_data_volatile(); -- Должно вернуть 3
COMMIT;
```

**Результаты:**

```bash
-- Первый вызов STABLE:
 id 
----
  1

-- Второй вызов STABLE (после UPDATE id=2):
 id 
----
  2

-- Первый вызов VOLATILE (после предыдущего теста, id=2):
 id 
----
  2

-- Второй вызов VOLATILE (после UPDATE id=3):
 id 
----
  3
```

**Выводы и объяснения:** На уровне READ COMMITTED обе функции (STABLE и VOLATILE) ведут себя одинаково - каждый вызов получает новый снимок данных и видит последние зафиксированные изменения. На уровне REPEATABLE READ STABLE функции используют снимок на момент первого вызова в транзакции, а VOLATILE функции могут получать новый снимок при каждом вызове.

#### Задача 3: Экспорт/импорт снимка

**Цель:** Продемонстрировать экспорт и импорт снимков данных.

**Выполненные действия:**

```sql
-- Подготовка
DROP TABLE IF EXISTS snapshot_test;
CREATE TABLE snapshot_test (id INT);
INSERT INTO snapshot_test VALUES (1);
```

```sql
-- Транзакция 1 (экспорт снимка)
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM snapshot_test;  -- id=1
SELECT pg_export_snapshot() as snapshot_id;
-- Получаем: 00000005-0000001C-1
-- Оставляем транзакцию открытой!
```

```sql
-- Транзакция 2 (изменение данных)
BEGIN;
UPDATE snapshot_test SET id = 100;
COMMIT;
```

```sql
-- Транзакция 3 (импорт снимка)
BEGIN ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION SNAPSHOT '00000005-0000001C-1';
SELECT * FROM snapshot_test;
COMMIT;
```

```sql
-- Завершение транзакции 1
COMMIT;
```

**Результаты:**

```bash
-- Транзакция 1 (экспорт):
 id 
----
  1

 pg_export_snapshot  
---------------------
 00000005-0000001C-1

-- Транзакция 3 (импорт снимка):
 id 
----
  1

-- Проверка вне транзакций:
 id 
----
 100
```

**Выводы и объяснения:** Транзакция 3, использующая импортированный снимок, видит данные в состоянии на момент экспорта снимка (id=1), несмотря на обновление в транзакции 2 (id=100). Это демонстрирует возможность работы с согласованными снимками данных во времени.

## Результаты выполнения

### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅Выполнено | READ COMMITTED видит последние зафиксированные данные |
| 1 | 2 | ✅Выполнено | REPEATABLE READ сохраняет снимок на начало транзакции |
| 1 | 3 | ✅Выполнено | DDL-операции транзакционны и невидимы до фиксации |
| 1 | 4 | ✅Выполнено | DROP TABLE блокируется при активных чтениях |
| 2 | 1 | ✅Выполнено | READ COMMITTED допускает фантомное чтение |
| 2 | 2 | ✅Выполнено | REPEATABLE READ скрывает удаления после первого чтения |
| 2 | 3 | ✅Выполнено | DDL полностью транзакционен |
| 3 | 1 | ✅Выполнено | Каждое изменение создает новую версию строки |
| 3 | 2 | ✅Выполнено | Системные таблицы также используют MVCC |
| 3 | 3 | ✅Выполнено | ON_ERROR_ROLLBACK использует SAVEPOINT для изоляции ошибок |
| 4 | 1 | ✅Выполнено | Видимость зависит от снимка на начало операции |
| 4 | 2 | ✅Выполнено | Категория функции влияет на момент создания снимка |
| 4 | 3 | ✅Выполнено | Снимки можно экспортировать и импортировать между транзакциями |

## Анализ и выводы

### Основные наблюдения

1. MVCC позволяет высокую конкурентность - чтение не блокирует запись, запись не блокирует чтение (кроме некоторых DDL)

2. Уровни изоляции определяют компромисс между согласованностью и производительностью:

    - READ COMMITTED: высокая конкурентность, но возможны аномалии

    - REPEATABLE READ: гарантирует повторяемость чтения, но может приводить к ошибкам сериализации

3. Версии строк накапливаются - каждый UPDATE/DELETE создает новую версию, требуется регулярный VACUUM

4. DDL полностью транзакционен - позволяет безопасно изменять структуру БД

### Сравнительный анализ

#### Сравнение уровней изоляции:

- READ COMMITTED: подходит для большинства OLTP-приложений

- REPEATABLE READ: необходим для отчетов и аналитических запросов

- SERIALIZABLE: для критически важных финансовых операций

#### Эффективность разных подходов:

- ON_ERROR_ROLLBACK увеличивает накладные расходы, но упрощает обработку ошибок

- Явное управление снимками полезно для сложных отчетов
