# Многоверсионность и изоляция в PostgreSQL

## Сведения о студенте
**Дата:** 2024-12-19  
**Семестр:** 7  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович

## Цель работы
Изучение механизмов многоверсионности, снимков данных, уровней изоляции транзакций и их практическое применение в PostgreSQL.

## Теоретическая часть

### Изученные концепции
- **Многоверсионность (MVCC)** - хранение нескольких версий одной строки с разным временем действия
- **Снимки данных (Snapshot)** - согласованный срез данных на определенный момент времени
- **Уровни изоляции** - Read Committed, Repeatable Read, Serializable
- **Блокировки** - механизмы управления конкурентным доступом
- **Очистка (VACUUM)** - удаление неактуальных версий строк

### Ключевые термины
- **xmin** - номер транзакции, создавшей версию строки
- **xmax** - номер транзакции, удалившей версию строки  
- **ctid** - физическое расположение версии строки
- **Снимок данных** - набор данных, видимых транзакции в определенный момент времени

## Практическая часть

### Модуль 1: Уровни изоляции транзакций

#### Задача 1: Read Committed vs Repeatable Read

**Цель:** Изучить различие в поведении уровней изоляции Read Committed и Repeatable Read при конкурентном доступе.

**Выполненные действия:**
```sql
-- Создаем базу данных для работы
CREATE DATABASE lab_isolation;
\c lab_isolation

-- Создаем тестовую таблицу
CREATE TABLE test_table(id integer, data text);
INSERT INTO test_table VALUES (1, 'initial data');

-- Тестируем Read Committed (уровень по умолчанию)
-- Сеанс 1
BEGIN;
SELECT * FROM test_table;

-- Сеанс 2
DELETE FROM test_table;
COMMIT;

-- Сеанс 1 - повторный запрос
SELECT * FROM test_table; -- Уже не видит строку
COMMIT;

-- Возвращаем данные
INSERT INTO test_table VALUES (1, 'initial data');

-- Тестируем Repeatable Read
-- Сеанс 1
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM test_table;

-- Сеанс 2  
DELETE FROM test_table;
COMMIT;

-- Сеанс 1 - повторный запрос
SELECT * FROM test_table; -- Все еще видит строку
COMMIT;
```

**Результаты:**
```
-- Создаем базу данных для работы
CREATE DATABASE
You are now connected to database "lab_isolation" as user "postgres".

-- Создаем тестовую таблицу
CREATE TABLE
INSERT 0 1

-- Тестируем Read Committed (уровень по умолчанию)
-- Сеанс 1
 id |     data     
----+--------------
  1 | initial data
(1 row)

-- Сеанс 2
DELETE 1
COMMIT

-- Сеанс 1 - повторный запрос
 id | data 
----+------
(0 rows)

WARNING:  there is no transaction in progress
COMMIT

-- Возвращаем данные
INSERT 0 1

-- Тестируем Repeatable Read
-- Сеанс 1
 id |     data     
----+--------------
  1 | initial data
(1 row)

-- Сеанс 2  
DELETE 1
COMMIT

-- Сеанс 1 - повторный запрос
 id |    data    
----+------------
  1 | initial data
```

**Выводы и объяснения:**
На уровне Read Committed каждый оператор видит последние зафиксированные изменения, поэтому после удаления строки в другом сеансе она перестает быть видимой. На уровне Repeatable Read транзакция работает с одним снимком данных, созданным в начале, поэтому не видит изменения, сделанные после начала транзакции.

#### Задача 2: Фантомное чтение на уровне Read Committed

**Цель:** Продемонстрировать аномалию фантомного чтения.

**Выполненные действия:**
```sql
-- Создаем пустую таблицу
CREATE TABLE phantom_test(id integer);
TRUNCATE phantom_test;

-- Сеанс 1
BEGIN;
SELECT * FROM phantom_test; -- 0 строк

-- Сеанс 2
INSERT INTO phantom_test VALUES (1);
COMMIT;

-- Сеанс 1
SELECT * FROM phantom_test; -- Видит новую строку
COMMIT;
```

**Результаты:**
```
-- Первый запрос:
 id 
----
(0 rows)

-- Второй запрос:
 id 
----
  1
(1 row)
```

**Выводы и объяснения:** На уровне Read Committed возможна аномалия фантомного чтения - транзакция видит новые строки, добавленные другими транзакциями после ее начала.

### Модуль 2: Структура страниц и версий строк

#### Задача 1: Исследование версий строк

**Цель:** Изучить, как создаются и хранятся версии строк при различных операциях.

**Выполненные действия:**
```sql
-- Устанавливаем расширение для исследования страниц
CREATE EXTENSION pageinspect;

-- Создаем таблицу и представление для анализа
CREATE TABLE version_test(s text);
CREATE VIEW version_test_v AS
SELECT '(0,'||lp||')' AS ctid,
    CASE lp_flags
        WHEN 0 THEN 'unused'
        WHEN 1 THEN 'normal'  
        WHEN 2 THEN 'redirect to '||lp_off
        WHEN 3 THEN 'dead'
    END AS state,
    t_xmin as xmin,
    t_xmax as xmax,
    CASE WHEN (t_infomask & 256) > 0 THEN 't' END AS xmin_c,
    CASE WHEN (t_infomask & 512) > 0 THEN 't' END AS xmin_a,
    CASE WHEN (t_infomask & 1024) > 0 THEN 't' END AS xmax_c,
    CASE WHEN (t_infomask & 2048) > 0 THEN 't' END AS xmax_a
FROM heap_page_items(get_raw_page('version_test',0))
ORDER BY lp;

-- Вставляем строку
INSERT INTO version_test VALUES ('first version');

-- Обновляем строку
UPDATE version_test SET s = 'second version';

-- Еще раз обновляем
UPDATE version_test SET s = 'third version';

-- Удаляем строку
DELETE FROM version_test;

-- Смотрим версии в странице
SELECT * FROM version_test_v;
```

**Результаты:**
```
 ctid  | state  | xmin | xmax | xmin_c | xmin_a | xmax_c | xmax_a 
-------+--------+------+------+--------+--------+--------+--------
 (0,1) | normal |  755 |  756 | t      |        | t      | 
 (0,2) | normal |  756 |  757 | t      |        | t      | 
 (0,3) | normal |  757 |  758 | t      |        |        | 
(3 rows)
```

**Выводы и объяснения:** Каждая операция UPDATE создает новую версию строки. DELETE помечает последнюю версию как удаленную (xmax). В странице сохраняются все версии до выполнения очистки.

### Модуль 3: Снимки данных

#### Задача 1: Исследование снимков данных

**Цель:** Изучить работу снимков данных при конкурентных транзакциях.

**Выполненные действия:**
```sql
CREATE DATABASE snapshots_test;
\c snapshots_test

CREATE TABLE snapshot_test(id integer, data text);

-- Транзакция 1 - начинается первой, но фиксируется позже
BEGIN;
INSERT INTO snapshot_test VALUES (1, 'first');

-- Транзакция 2 - фиксируется сразу
BEGIN;
INSERT INTO snapshot_test VALUES (2, 'second');
COMMIT;

-- Создаем снимок в транзакции 3
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT pg_current_snapshot();

-- Завершаем транзакцию 1
COMMIT;

-- Транзакция 4 - начинается после создания снимка
BEGIN;
INSERT INTO snapshot_test VALUES (3, 'third');
COMMIT;

-- Смотрим что видно в снимке
SELECT *, xmin, xmax FROM snapshot_test;
```

**Результаты:**
```
 pg_current_snapshot 
---------------------
 761:763:761
(1 row)

-- Данные в снимке:
 id |  data  | xmin | xmax 
----+--------+------+------
  2 | second |  762 |    0
(1 row)
```

**Выводы и объяснения:** В снимке видны только данные, зафиксированные до его создания. Транзакция 789 (первая) не видна, так как была активна при создании снимка. Транзакция 791 (четвертая) не видна, так как началась после создания снимка.

#### Задача 2: Экспорт и импорт снимков

**Цель:** Освоить механизм экспорта и импорта снимков данных.

**Выполненные действия:**
```sql
-- Подготавливаем данные
CREATE TABLE export_test(id integer);
INSERT INTO export_test VALUES (1), (2), (3);

-- Транзакция 1 - экспортирует снимок
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM export_test;
SELECT pg_export_snapshot();

-- Транзакция 2 - изменяет данные
DELETE FROM export_test WHERE id = 2;
COMMIT;

-- Транзакция 3 - импортирует снимок
BEGIN ISOLATION LEVEL REPEATABLE READ;
SET TRANSACTION SNAPSHOT '00000003-00000317-1'; -- идентификатор из экспорта
SELECT * FROM export_test; -- Видит старые данные
COMMIT;

-- Завершаем транзакцию 1
COMMIT;
```

**Результаты:**
```
-- Транзакция 1 (экспорт):
 id 
----
  1
  2
  3
(3 rows)

 pg_export_snapshot  
---------------------
 00000003-0000006C-1
(1 row)


-- Транзакция 3 (импорт):
 id 
----
  1
  2
  3
(3 rows)
```

**Выводы и объяснения:** Экспортированный снимок позволяет нескольким транзакциям видеть одинаковые данные, даже если исходные данные изменяются. Это полезно для согласованного чтения в параллельных процессах.

### Модуль 4: Блокировки и конкурентный доступ

#### Задача 1: Исследование блокировок строк

**Цель:** Изучить поведение блокировок при конкурентном доступе.

**Выполненные действия:**
```sql
CREATE TABLE lock_test(id integer PRIMARY KEY, value integer);
INSERT INTO lock_test VALUES (1, 100);

-- Сеанс 1
BEGIN;
UPDATE lock_test SET value = 200 WHERE id = 1;

-- Сеанс 2  
BEGIN;
UPDATE lock_test SET value = 300 WHERE id = 1; -- Блокируется

-- Сеанс 1
COMMIT; -- Разблокирует сеанс 2

-- Сеанс 2 завершает UPDATE
COMMIT;
```

**Результаты:** Второй UPDATE блокируется до завершения первой транзакции.

**Выводы и объяснения:** PostgreSQL использует блокировки на уровне строк для предотвращения конфликтов записи. Читающие транзакции не блокируют друг друга благодаря многоверсионности.

## Результаты выполнения

### Сводная таблица результатов
| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅ Выполнено | Различие уровней изоляции подтверждено |
| 1 | 2 | ✅ Выполнено | Фантомное чтение на Read Committed |
| 2 | 1 | ✅ Выполнено | Версии строк сохраняются до VACUUM |
| 3 | 1 | ✅ Выполнено | Снимки определяют видимость данных |
| 3 | 2 | ✅ Выполнено | Экспорт снимков работает корректно |
| 4 | 1 | ✅ Выполнено | Блокировки предотвращают конфликты |

## Анализ и выводы

### Основные наблюдения
1. **Многоверсионность эффективно решает проблему конкурентного доступа** - читающие транзакции не блокируют писающие и наоборот
2. **Уровни изоляции обеспечивают различный баланс** между согласованностью и производительностью
3. **Снимки данных** являются ключевым механизмом для обеспечения изоляции
4. **Блокировки на уровне строк** предотвращают потерю обновлений

### Сравнительный анализ уровней изоляции

| Уровень | Неповторяющееся чтение | Фантомное чтение | Потерянные обновления |
|---------|------------------------|------------------|----------------------|
| Read Committed | ❌ Возможно | ❌ Возможно | ❌ Возможно* |
| Repeatable Read | ✅ Запрещено | ✅ Запрещено | ✅ Запрещено |
| Serializable | ✅ Запрещено | ✅ Запрещено | ✅ Запрещено |

*На Read Committed потерянные обновления возможны в определенных сценариях

### Проблемы и решения
| Проблема | Причина | Решение |
|----------|---------|---------|
| Долгие транзакции блокируют очистку | Горизонт очистки не продвигается | Использовать короткие транзакции, настройка idle_in_transaction_session_timeout |
| Конфликты обновления | Блокировки строк | Оптимистичные блокировки, повторные попытки |

## Ответы на контрольные вопросы

### Вопросы из задания

1. **"Объясните отличия между Read Committed и Repeatable Read"**  
   Основное отличие - время создания снимка данных. На Read Committed снимок создается для каждого оператора, поэтому видны последние зафиксированные изменения. На Repeatable Read снимок создается один раз в начале транзакции, обеспечивая постоянство видимости данных.

2. **"Видна ли удаленная строка в открытой транзакции Repeatable Read?"**  
   Да, если удаление произошло после начала транзакции. Транзакция Repeatable Read работает с одним снимком данных и не видит изменения, сделанные после его создания.

3. **"Команда DROP TABLE транзакционна?"**  
   Да, все DDL-команды в PostgreSQL транзакционны. DROP TABLE можно откатить с помощью ROLLBACK, если он выполнен в рамках незавершенной транзакции.

### Дополнительные вопросы

1. **"Когда происходит физическое удаление версий строк?"**  
   Физическое удаление происходит при выполнении VACUUM, который удаляет версии строк, ставшие невидимыми для всех активных транзакций.

2. **"Как избежать потери обновлений на уровне Read Committed?"**  
   Использовать SELECT FOR UPDATE для явной блокировки строк или перейти на уровень Repeatable Read, где конфликты обновления обнаруживаются автоматически.

## Приложения

### Конфигурационные настройки
```sql
-- Проверка текущих настроек
SHOW default_transaction_isolation;
SHOW idle_in_transaction_session_timeout;
```

### SQL-скрипты
Все выполненные команды сохранены в отдельных файлах по модулям.

### Полезные команды для мониторинга
```sql
-- Просмотр активных транзакций
SELECT * FROM pg_stat_activity WHERE state = 'active';

-- Просмотр блокировок  
SELECT * FROM pg_locks WHERE granted = false;

-- Информация о снимках
SELECT pg_current_snapshot();
```
