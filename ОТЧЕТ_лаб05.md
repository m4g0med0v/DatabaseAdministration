# Отчет по лабораторной работе №5  
# Надежность: Журнал предзаписи (WAL)

## Сведения о студенте

**Дата:** 14.11.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович  

## Цель работы

Изучение работы буферного кеша и механизма журналирования предзаписи (WAL) в PostgreSQL, а также получение практических навыков управления контрольными точками, анализа журнальных записей, настройки параметров WAL и исследования процессов восстановления после сбоев.

## Теоретическая часть

### Изученные концепции

- **Буферный кеш:** Область общей памяти PostgreSQL, в которой кэшируются страницы данных, считываемые с диска, что позволяет уменьшать количество операций ввода‑вывода.

- **Грязные буферы:** Страницы в буферном кеше, которые были изменены в памяти, но ещё не записаны обратно в файлы данных на диске.

- **Контрольная точка (Checkpoint):** Процесс принудительной записи всех грязных буферов на диск и фиксации точки в журнале WAL, начиная с которой возможно восстановление, что ограничивает объём журнала, необходимый для восстановления.

- **Журнал предзаписи (WAL):** Последовательный журнал, в который все изменения данных записываются перед записью самих страниц на диск, обеспечивая надёжность и возможность восстановления после сбоев.

- **Восстановление (Recovery):** Процесс применения WAL‑записей, созданных после последней контрольной точки, к данным на диске для приведения базы в согласованное состояние после сбоя.

- **pg_prewarm:** Расширение PostgreSQL для предзагрузки страниц таблиц и индексов в буферный кеш для ускорения дальнейшего доступа к данным.

- **full_page_writes:** Параметр, при включении которого сервер записывает в WAL полные образы страниц при первом изменении после контрольной точки для защиты от частичных записей страниц при сбое.

- **wal_compression:** Параметр, включающий сжатие полных образов страниц, записываемых в WAL, что уменьшает объём журнала за счёт дополнительной нагрузки на CPU.

### Ключевые термины

- **WAL‑записи:** Структурированные записи в журнале предзаписи, описывающие логические или физические изменения страниц данных и служебных структур.

- **Сегмент WAL:** Файл фиксированного размера (обычно 16 МБ), в который последовательно записываются WAL‑записи до его переполнения и переключения на следующий сегмент.

- **Точка REDO:** Позиция в WAL (LSN), начиная с которой при восстановлении необходимо применять записи журнала после контрольной точки.

- **pg_waldump:** Утилита для построчного просмотра содержимого WAL‑файлов в человекочитаемом виде, полезная для отладки и учебных целей.

- **LSN (Log Sequence Number):** Логический адрес в WAL, однозначно идентифицирующий позицию записи журнала и используемый при репликации и восстановлении.

## Практическая часть

### Модуль 1: Процессы и режимы остановки

#### Задача 1: Поиск процессов

**Цель:** Найти процессы PostgreSQL, отвечающие за буферный кеш (checkpointer, background writer) и журнал предзаписи WAL (walwriter).

**Выполненные действия:**

```bash
ps aux | grep "postgres:"
```

**Результаты:**

```bash
postgres     863  0.0  0.2 225588  8628 ?        Ss   08:51   0:00 postgres: 16/main: checkpointer 
postgres     864  0.0  0.1 225612  7060 ?        Ss   08:51   0:00 postgres: 16/main: background writer 
postgres    1364  0.0  0.2 225456 10264 ?        Ss   08:51   0:00 postgres: 16/main: walwriter 
postgres    1365  0.0  0.2 227064  8584 ?        Ss   08:51   0:00 postgres: 16/main: autovacuum launcher 
postgres    1366  0.0  0.1 227040  7904 ?        Ss   08:51   0:00 postgres: 16/main: logical replication launcher 
student   244512  0.0  0.0 203268  3372 ?        Ss   11:49   0:00 postgres: checkpointer 
student   244513  0.0  0.0 203292  3528 ?        Ss   11:49   0:00 postgres: background writer 
student   244515  0.0  0.1 203136  7636 ?        Ss   11:49   0:00 postgres: walwriter 
student   244516  0.2  0.1 204740  6112 ?        Ss   11:49   0:00 postgres: autovacuum launcher 
student   244517  0.0  0.1 204720  5264 ?        Ss   11:49   0:00 postgres: logical replication launcher 
```

**Выводы и объяснения:**
Процессы postgres: ... checkpointer и postgres: ... background writer отвечают за работу с буферным кешем: контрольная точка сбрасывает грязные страницы на диск, а background writer помогает постепенно записывать изменённые буферы, чтобы разгрузить контрольные точки.​
Процесс postgres: ... walwriter отвечает за журнал предзаписи WAL, записывая накопленные WAL‑записи на диск независимо от основных рабочих процессов, что уменьшает задержки при коммите транзакций.​

#### Задача 2: Остановка Fast

**Цель:** Остановить кластер PostgreSQL в режиме fast, перезапустить его и найти в журнале сообщений запись о контрольной точке, выполненной при завершении работы.

**Выполненные действия:**

```bash
sudo pg_ctlcluster 16 main stop
sudo pg_ctlcluster 16 main start
sudo tail -n 50 /home/student/logfile
```

**Результаты:**

```bash
2025-11-14 11:49:43.140 MSK [244382] LOG:  received fast shutdown request
2025-11-14 11:49:43.150 MSK [244382] LOG:  aborting any active transactions
2025-11-14 11:49:43.152 MSK [244383] LOG:  shutting down
2025-11-14 11:49:43.157 MSK [244383] LOG:  checkpoint starting: shutdown immediate
2025-11-14 11:49:43.188 MSK [244383] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.003 s, total=0.036 s; sync files=2, longest=0.002 s, average=0.002 s; distance=0 kB, estimate=0 kB; lsn=0/3992FC50, redo lsn=0/3992FC50
2025-11-14 11:49:43.194 MSK [244382] LOG:  database system is shut down
```

**Выводы и объяснения:**
При fast‑остановке сервер получает запрос fast shutdown, прерывает активные транзакции и выполняет контрольную точку с типом shutdown immediate, о чём прямо говорит строка checkpoint starting: shutdown immediate.​
Эта контрольная точка записывает на диск все грязные буферы и фиксирует положение в WAL, благодаря чему при следующем запуске система видит, что база была корректно завершена и может сразу перейти в состояние "готова принимать подключения".​

#### Задача 3: Остановка Immediate

**Цель:** Выполнить аварийную (immediate) остановку PostgreSQL, затем найти в журнале сообщения о восстановлении после сбоя и сравнить поведение с режимом fast.

**Выполненные действия:**

```bash
sudo pg_ctlcluster 16 main stop -m immediate
sudo pg_ctlcluster 16 main start
sudo tail -n 50 /home/student/logfile
```

**Результаты:**

```bash
2025-11-14 11:49:43.140 MSK [244382] LOG:  received fast shutdown request
2025-11-14 11:49:43.150 MSK [244382] LOG:  aborting any active transactions
2025-11-14 11:49:43.157 MSK [244383] LOG:  checkpoint starting: shutdown immediate
2025-11-14 11:49:43.188 MSK [244383] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.003 s, total=0.036 s; ...
2025-11-14 11:49:43.194 MSK [244382] LOG:  database system is shut down
2025-11-14 11:49:43.284 MSK [244511] LOG:  starting PostgreSQL 16.0 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit
2025-11-14 11:49:43.304 MSK [244514] LOG:  database system was shut down at 2025-11-14 11:49:43 MSK
2025-11-14 11:49:43.313 MSK [244511] LOG:  database system is ready to accept connections
```

**Выводы и объяснения:**
В приведённом фрагменте лога видно корректную fast‑остановку с выполнением контрольной точки checkpoint starting: shutdown immediate, поэтому при последующем запуске сервер пишет, что система базы данных была корректно завершена, и сообщений о восстановлении (recovery) нет.​Для режима -m immediate в логе должны появляться строки о некорректном завершении и автоматическом восстановлении по WAL (например, database system was not properly shut down; automatic recovery in progress), то есть сейчас в файле logfile выведен не результат immediate‑остановки, а предыдущий сценарий fast‑shutdown, и для полного выполнения задания нужно повторить просмотр именно актуального журнала PostgreSQL после -m immediate и найти там сообщения о recovery.​

### Модуль 2: Буферный кеш и контрольные точки

#### Задача 1: Анализ размера

**Цель:** Определить, сколько страниц на диске занимает таблица wal_test, и сколько буферов этой таблицы находится в буферном кеше.

**Выполненные действия:**

```sql
-- 2. Создать таблицу wal_test
CREATE TABLE wal_test (
    id   INT,
    data TEXT
);

-- 3. Вставить достаточное количество строк (примерно несколько тысяч)
INSERT INTO wal_test (id, data)
SELECT g, repeat('x', 1000)
FROM generate_series(1, 5000) AS g;

-- 4. Принудительно записать данные на диск, чтобы размер был актуален
CHECKPOINT;

-- 5. Посчитать, сколько страниц на диске занимает таблица
SELECT
    pg_relation_size('wal_test') AS bytes,
    current_setting('block_size')::int AS block_size,
    pg_relation_size('wal_test') / current_setting('block_size')::int AS pages;

-- 6. Убедиться, что расширение pg_buffercache доступно (один раз в БД)
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

-- 7. Посчитать, сколько буферов в кеше занято таблицей wal_test
SELECT
    count(*) AS buffers
FROM
    pg_buffercache b
WHERE
    b.relfilenode = pg_relation_filenode('wal_test'::regclass)
    AND b.reldatabase IN (0, (SELECT oid FROM pg_database WHERE datname = current_database()));
```

**Результаты:**

```bash
 bytes  | block_size | pages 
--------+------------+-------
 5857280|       8192 |   715

 buffers 
---------
     719
```

**Выводы и объяснения:**
Таблица wal_test занимает 5 857 280 байт, что при размере блока 8 192 байта соответствует 715 страницам на диске, то есть физический размер рассчитывается как целое количество блоков данных.​
В буферном кеше таблица занимает 719 буферов, что примерно соответствует числу её дисковых страниц, так как каждая строка в pg_buffercache представляет один загруженный в shared_buffers блок таблицы.

#### Задача 2: Грязные буферы и контрольная точка

**Цель:** Определить количество "грязных" буферов в кеше до и после выполнения контрольной точки и объяснить изменение.

**Выполненные действия:**

```sql
-- 1. Посчитать общее количество грязных буферов в кеше
SELECT
    count(*) AS dirty_buffers
FROM
    pg_buffercache
WHERE
    isdirty;

-- 2. Выполнить контрольную точку
CHECKPOINT;

-- 3. Повторно посчитать количество грязных буферов
SELECT
    count(*) AS dirty_buffers
FROM
    pg_buffercache
WHERE
    isdirty;
```

**Результаты:**

```bash
 dirty_buffers 
---------------
             0
(1 row)

CHECKPOINT

 dirty_buffers 
---------------
             0
(1 row)
```

**Выводы и объяснения:**
В момент первого запроса все буферы в кеше уже были чистыми (dirty_buffers = 0), то есть все изменённые страницы до этого успели сброситься на диск background writer’ом и/или предыдущими контрольными точками.​
Команда CHECKPOINT в такой ситуации не находит грязных страниц для записи и лишь фиксирует контрольную точку в WAL, поэтому после неё количество грязных буферов остаётся нулевым, изменений в кеше не наблюдается.

#### Задача 3: Предварительное чтение (pg_prewarm)

**Цель:** Загрузить таблицу wal_test в буферный кеш с помощью pg_prewarm, перезапустить сервер и проверить, осталась ли таблица в кеше, чтобы оценить эффективность метода.

**Выполненные действия:**

```sql
-- 1. Подключить расширение pg_prewarm (в нужной БД)
CREATE EXTENSION IF NOT EXISTS pg_prewarm;

-- 2. Проверить, сколько буферов таблицы wal_test уже в кеше
SELECT
    count(*) AS buffers_before
FROM
    pg_buffercache b
WHERE
    b.relfilenode = pg_relation_filenode('wal_test'::regclass)
    AND b.reldatabase IN (0, (SELECT oid FROM pg_database WHERE datname = current_database()));

-- 3. Загрузить таблицу wal_test в буферный кеш
SELECT pg_prewarm('wal_test'::regclass, 'buffer');

-- 4. Ещё раз проверить количество буферов таблицы в кеше
SELECT
    count(*) AS buffers_after_prewarm
FROM
    pg_buffercache b
WHERE
    b.relfilenode = pg_relation_filenode('wal_test'::regclass)
    AND b.reldatabase IN (0, (SELECT oid FROM pg_database WHERE datname = current_database()));
```

```bash
# 5. Перезапустить кластер, чтобы очистить shared_buffers
sudo pg_ctlcluster 16 main restart
```

```sql
-- 6. После перезапуска снова проверить буферы таблицы
SELECT
    count(*) AS buffers_after_restart
FROM
    pg_buffercache b
WHERE
    b.relfilenode = pg_relation_filenode('wal_test'::regclass)
    AND b.reldatabase IN (0, (SELECT oid FROM pg_database WHERE datname = current_database()));
```

**Результаты:**

```bash
 buffers_before 
----------------
            719

 pg_prewarm 
------------
        715

 buffers_after_prewarm 
-----------------------
                   719

 buffers_after_restart 
-----------------------
                   719
```

**Выводы и объяснения:**
До вызова pg_prewarm таблица уже практически полностью находилась в кеше (719 буферов), поэтому дополнительный прогрев загрузил ещё до 715 страниц, но общее число буферов практически не изменилось, так как кеш и так был заполнен страницами этой таблицы.​
После перезапуска кластера количество буферов для wal_test осталось тем же (719), что означает, что кеш не очищается между рестартами в вашей конфигурации (лог-файл лежит в домашнем каталоге, а кластер, вероятно, не полностью перезапускает shared_buffers), либо таблица была быстро повторно прочитана после запуска; в любом случае разовый pg_prewarm здесь не дал заметного эффекта по сравнению с уже прогретым кешем.​

### Модуль 3: Журнал предзаписи (WAL)

#### Задача 1: Размер WAL-записей

**Цель:** Определить объём WAL-записей, сгенерированных транзакцией с созданием таблицы с первичным ключом и вставкой нескольких строк, с помощью разницы позиций LSN.

**Выполненные действия:**

```sql
-- 1. Зафиксировать текущую позицию WAL
SELECT pg_current_wal_lsn();

-- 2. Создать таблицу с первичным ключом и вставить несколько строк
DROP TABLE IF EXISTS wal_lsn_test;
CREATE TABLE wal_lsn_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO wal_lsn_test (id, data) VALUES
    (1, 'a'),
    (2, 'b'),
    (3, 'c'),
    (4, 'd'),
    (5, 'e');

-- 3. Зафиксировать транзакцию (если работал в явной транзакции)
COMMIT;

-- 4. Посмотреть новую позицию WAL
SELECT pg_current_wal_lsn();

-- 5. Посчитать объём сгенерированного WAL в байтах
SELECT
    pg_current_wal_lsn() - '0/3A3012F8'::pg_lsn AS wal_bytes_raw,
    pg_size_pretty(pg_current_wal_lsn() - '0/3A3012F8'::pg_lsn) AS wal_bytes_pretty;
```

**Результаты:**

```bash
 pg_current_wal_lsn 
--------------------
 0/3A3012F8
(1 row)              # до вставки

 pg_current_wal_lsn 
--------------------
 0/3A32F488
(1 row)              # после вставки и коммита

 wal_bytes_raw | wal_bytes_pretty 
---------------+------------------
        188872 | 184 kB
(1 row)
```

**Выводы и объяснения:**
За время между двумя вызовами pg_current_wal_lsn() было сгенерировано 188 872 байта WAL, что примерно соответствует 184 kB журнальных записей, включающих создание таблицы, индекса по первичному ключу и сами вставки строк.​
Объём WAL существенно превосходит размер логических данных, потому что в журнал попадают подробные описания изменений структуры и данных, необходимые для надёжного восстановления и репликации, а также дополнительные служебные данные и, при необходимости, полные образы страниц.

#### Задача 2: Анализ WAL

**Цель:** Пояснить, почему даже небольшая операция (создание таблицы и вставка 5 строк) сгенерировала относительно большой объём WAL, и при необходимости использовать pg_waldump для просмотра заголовков записей.

**Выполненные действия:**

```bash
pg_waldump -p /home/student/pgsql16/data/pg_wal --start=0/3A3012F8 --end=0/3A32F488
```

**Результаты:**

```bash
rmgr: Standby     len (rec/tot):     42/    42, tx:     622832, lsn: 0/3A3012F8, prev 0/3A3012C0, desc: LOCK xid 622832 db 24605 rel 24623 
rmgr: XLOG        len (rec/tot):     49/  6493, tx:     622832, lsn: 0/3A301328, prev 0/3A3012F8, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2608 blk 12 FPW
rmgr: Standby     len (rec/tot):     42/    42, tx:     622832, lsn: 0/3A302CA0, prev 0/3A301328, desc: LOCK xid 622832 db 24605 rel 24626 
rmgr: Standby     len (rec/tot):     42/    42, tx:     622832, lsn: 0/3A302CD0, prev 0/3A302CA0, desc: LOCK xid 622832 db 24605 rel 24628 
rmgr: Standby     len (rec/tot):     42/    42, tx:     622832, lsn: 0/3A302D00, prev 0/3A302CD0, desc: LOCK xid 622832 db 24605 rel 24627 
rmgr: XLOG        len (rec/tot):     49/  3269, tx:     622832, lsn: 0/3A302D30, prev 0/3A302D00, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/1247 blk 14 FPW
rmgr: XLOG        len (rec/tot):     49/  3821, tx:     622832, lsn: 0/3A3039F8, prev 0/3A302D30, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2606 blk 2 FPW
rmgr: Heap        len (rec/tot):     59/  8227, tx:     622832, lsn: 0/3A304900, prev 0/3A3039F8, desc: DELETE xmax: 622832, off: 6, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2610 blk 1 FPW
rmgr: Heap        len (rec/tot):     59/  3931, tx:     622832, lsn: 0/3A306940, prev 0/3A304900, desc: DELETE xmax: 622832, off: 26, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57 FPW
rmgr: Heap        len (rec/tot):     59/  5955, tx:     622832, lsn: 0/3A3078A0, prev 0/3A306940, desc: DELETE xmax: 622832, off: 6, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1259 blk 1 FPW
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309000, prev 0/3A3078A0, desc: DELETE xmax: 622832, off: 107, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309038, prev 0/3A309000, desc: DELETE xmax: 622832, off: 15, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2606 blk 2
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309070, prev 0/3A309038, desc: DELETE xmax: 622832, off: 106, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3090A8, prev 0/3A309070, desc: DELETE xmax: 622832, off: 2, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2610 blk 1
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3090E0, prev 0/3A3090A8, desc: DELETE xmax: 622832, off: 24, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309118, prev 0/3A3090E0, desc: DELETE xmax: 622832, off: 25, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309150, prev 0/3A309118, desc: DELETE xmax: 622832, off: 4, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1259 blk 1
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309188, prev 0/3A309150, desc: DELETE xmax: 622832, off: 103, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3091C0, prev 0/3A309188, desc: DELETE xmax: 622832, off: 104, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3091F8, prev 0/3A3091C0, desc: DELETE xmax: 622832, off: 23, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309230, prev 0/3A3091F8, desc: DELETE xmax: 622832, off: 22, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309268, prev 0/3A309230, desc: DELETE xmax: 622832, off: 21, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3092A0, prev 0/3A309268, desc: DELETE xmax: 622832, off: 20, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3092D8, prev 0/3A3092A0, desc: DELETE xmax: 622832, off: 19, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309310, prev 0/3A3092D8, desc: DELETE xmax: 622832, off: 18, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309348, prev 0/3A309310, desc: DELETE xmax: 622832, off: 15, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309380, prev 0/3A309348, desc: DELETE xmax: 622832, off: 16, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3093B8, prev 0/3A309380, desc: DELETE xmax: 622832, off: 17, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3093F0, prev 0/3A3093B8, desc: DELETE xmax: 622832, off: 3, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1259 blk 1
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309428, prev 0/3A3093F0, desc: DELETE xmax: 622832, off: 105, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309460, prev 0/3A309428, desc: DELETE xmax: 622832, off: 17, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1247 blk 14
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309498, prev 0/3A309460, desc: DELETE xmax: 622832, off: 101, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3094D0, prev 0/3A309498, desc: DELETE xmax: 622832, off: 16, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1247 blk 14
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309508, prev 0/3A3094D0, desc: DELETE xmax: 622832, off: 100, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309540, prev 0/3A309508, desc: DELETE xmax: 622832, off: 14, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309578, prev 0/3A309540, desc: DELETE xmax: 622832, off: 13, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3095B0, prev 0/3A309578, desc: DELETE xmax: 622832, off: 12, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3095E8, prev 0/3A3095B0, desc: DELETE xmax: 622832, off: 11, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309620, prev 0/3A3095E8, desc: DELETE xmax: 622832, off: 10, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309658, prev 0/3A309620, desc: DELETE xmax: 622832, off: 9, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309690, prev 0/3A309658, desc: DELETE xmax: 622832, off: 7, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A3096C8, prev 0/3A309690, desc: DELETE xmax: 622832, off: 8, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1249 blk 57
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309700, prev 0/3A3096C8, desc: DELETE xmax: 622832, off: 5, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/1259 blk 1
rmgr: Heap        len (rec/tot):     54/    54, tx:     622832, lsn: 0/3A309738, prev 0/3A309700, desc: DELETE xmax: 622832, off: 102, infobits: [KEYS_UPDATED], flags: 0x00, blkref #0: rel 1663/24605/2608 blk 12
rmgr: Transaction len (rec/tot):   1245/  1245, tx:     622832, lsn: 0/3A309770, prev 0/3A309738, desc: COMMIT 2025-11-14 12:38:32.163069 MSK; rels: base/24605/24623 base/24605/24626 base/24605/24627 base/24605/24628; dropped stats: 2/24605/24628 2/24605/24627 2/24605/24626 2/24605/24623; inval msgs: catcache 32 catcache 7 catcache 6 catcache 55 catcache 54 catcache 19 catcache 32 catcache 7 catcache 6 catcache 7 catcache 6 catcache 55 catcache 54 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 55 catcache 54 catcache 80 catcache 79 catcache 80 catcache 79 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 55 catcache 54 relcache 24628 relcache 24623 snapshot 2608 snapshot 2608 relcache 24627 relcache 24626 snapshot 2608 relcache 24626 snapshot 2608 snapshot 2608 snapshot 2608 relcache 24623 snapshot 2608
rmgr: XLOG        len (rec/tot):     49/  4897, tx:          0, lsn: 0/3A309C50, prev 0/3A309770, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2663 blk 2 FPW
rmgr: XLOG        len (rec/tot):     49/  6473, tx:          0, lsn: 0/3A30AF90, prev 0/3A309C50, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2704 blk 2 FPW
rmgr: Storage     len (rec/tot):     42/    42, tx:          0, lsn: 0/3A30C8F8, prev 0/3A30AF90, desc: CREATE base/24605/24630
rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/3A30C928, prev 0/3A30C8F8, desc: PRUNE snapshotConflictHorizon: 622832, nredirected: 0, ndead: 2, nunused: 0, redirected: [], dead: [2, 6], unused: [], blkref #0: rel 1663/24605/2610 blk 1
rmgr: Heap        len (rec/tot):    211/   211, tx:     622833, lsn: 0/3A30C968, prev 0/3A30C928, desc: INSERT off: 18, flags: 0x00, blkref #0: rel 1663/24605/1247 blk 14
rmgr: Btree       len (rec/tot):     53/  5173, tx:     622833, lsn: 0/3A30CA40, prev 0/3A30C968, desc: INSERT_LEAF off: 254, blkref #0: rel 1663/24605/2703 blk 2 FPW
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A30DE78, prev 0/3A30CA40, desc: INSERT_LEAF off: 180, blkref #0: rel 1663/24605/2704 blk 2
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A30DEC8, prev 0/3A30DE78, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [108], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     53/  7509, tx:     622833, lsn: 0/3A30DF20, prev 0/3A30DEC8, desc: INSERT_LEAF off: 163, blkref #0: rel 1663/24605/2673 blk 4 FPW
rmgr: Btree       len (rec/tot):     53/  5581, tx:     622833, lsn: 0/3A30FC90, prev 0/3A30DF20, desc: INSERT_LEAF off: 117, blkref #0: rel 1663/24605/2674 blk 7 FPW
rmgr: XLOG        len (rec/tot):     49/  7121, tx:     622833, lsn: 0/3A311278, prev 0/3A30FC90, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2704 blk 4 FPW
rmgr: Heap        len (rec/tot):    211/   211, tx:     622833, lsn: 0/3A312E68, prev 0/3A311278, desc: INSERT off: 19, flags: 0x00, blkref #0: rel 1663/24605/1247 blk 14
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A312F40, prev 0/3A312E68, desc: INSERT_LEAF off: 254, blkref #0: rel 1663/24605/2703 blk 2
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A312F80, prev 0/3A312F40, desc: INSERT_LEAF off: 73, blkref #0: rel 1663/24605/2704 blk 4
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A312FD0, prev 0/3A312F80, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [109], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A313028, prev 0/3A312FD0, desc: INSERT_LEAF off: 163, blkref #0: rel 1663/24605/2673 blk 4
rmgr: Btree       len (rec/tot):     53/  5469, tx:     622833, lsn: 0/3A313070, prev 0/3A313028, desc: INSERT_LEAF off: 107, blkref #0: rel 1663/24605/2674 blk 5 FPW
rmgr: Heap        len (rec/tot):     54/  7282, tx:     622833, lsn: 0/3A3145E8, prev 0/3A313070, desc: INSERT off: 38, flags: 0x01, blkref #0: rel 1663/24605/1259 blk 5 FPW
rmgr: Btree       len (rec/tot):     53/  2593, tx:     622833, lsn: 0/3A316278, prev 0/3A3145E8, desc: INSERT_LEAF off: 125, blkref #0: rel 1663/24605/2662 blk 2 FPW
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A316CA0, prev 0/3A316278, desc: INSERT_LEAF off: 129, blkref #0: rel 1663/24605/2663 blk 2
rmgr: Btree       len (rec/tot):     53/  6701, tx:     622833, lsn: 0/3A316CF0, prev 0/3A316CA0, desc: INSERT_LEAF off: 289, blkref #0: rel 1663/24605/3455 blk 1 FPW
rmgr: Heap2       len (rec/tot):    302/   302, tx:     622833, lsn: 0/3A318738, prev 0/3A316CF0, desc: MULTI_INSERT ntuples: 2, flags: 0x02, offsets: [27, 28], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     53/  8017, tx:     622833, lsn: 0/3A318868, prev 0/3A318738, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2658 blk 15 FPW
rmgr: Btree       len (rec/tot):     53/  4473, tx:     622833, lsn: 0/3A31A7D8, prev 0/3A318868, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10 FPW
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31B958, prev 0/3A31A7D8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31B9A0, prev 0/3A31B958, desc: INSERT_LEAF off: 220, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Heap2       len (rec/tot):    806/   806, tx:     622833, lsn: 0/3A31B9E0, prev 0/3A31B9A0, desc: MULTI_INSERT ntuples: 6, flags: 0x02, offsets: [29, 30, 31, 32, 33, 34], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BD08, prev 0/3A31B9E0, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BD50, prev 0/3A31BD08, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BD90, prev 0/3A31BD50, desc: INSERT_LEAF off: 230, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BDD8, prev 0/3A31BD90, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BE18, prev 0/3A31BDD8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BE60, prev 0/3A31BE18, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BEA0, prev 0/3A31BE60, desc: INSERT_LEAF off: 231, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BEE8, prev 0/3A31BEA0, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BF28, prev 0/3A31BEE8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BF70, prev 0/3A31BF28, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31BFB0, prev 0/3A31BF70, desc: INSERT_LEAF off: 232, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31BFF8, prev 0/3A31BFB0, desc: INSERT_LEAF off: 219, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A31C050, prev 0/3A31BFF8, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [110], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     53/  8233, tx:     622833, lsn: 0/3A31C0A8, prev 0/3A31C050, desc: INSERT_LEAF off: 291, blkref #0: rel 1663/24605/2673 blk 8 FPW
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31E0F0, prev 0/3A31C0A8, desc: INSERT_LEAF off: 130, blkref #0: rel 1663/24605/2674 blk 7
rmgr: Standby     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A31E138, prev 0/3A31E0F0, desc: LOCK xid 622833 db 24605 rel 24630 
rmgr: Storage     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A31E168, prev 0/3A31E138, desc: CREATE base/24605/24633
rmgr: Heap        len (rec/tot):    203/   203, tx:     622833, lsn: 0/3A31E198, prev 0/3A31E168, desc: INSERT off: 40, flags: 0x00, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31E268, prev 0/3A31E198, desc: INSERT_LEAF off: 126, blkref #0: rel 1663/24605/2662 blk 2
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A31E2A8, prev 0/3A31E268, desc: INSERT_LEAF off: 11, blkref #0: rel 1663/24605/2663 blk 2
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31E2F8, prev 0/3A31E2A8, desc: INSERT_LEAF off: 290, blkref #0: rel 1663/24605/3455 blk 1
rmgr: Heap2       len (rec/tot):    428/   428, tx:     622833, lsn: 0/3A31E338, prev 0/3A31E2F8, desc: MULTI_INSERT ntuples: 3, flags: 0x02, offsets: [35, 36, 37], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31E4E8, prev 0/3A31E338, desc: INSERT_LEAF off: 235, blkref #0: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31E530, prev 0/3A31E4E8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Standby     len (rec/tot):     42/    42, tx:          0, lsn: 0/3A31E570, prev 0/3A31E530, desc: LOCK xid 622833 db 24605 rel 24630 
rmgr: Standby     len (rec/tot):     54/    54, tx:          0, lsn: 0/3A31E5A0, prev 0/3A31E570, desc: RUNNING_XACTS nextXid 622834 latestCompletedXid 622832 oldestRunningXid 622833; 1 xacts: 622833
rmgr: Btree       len (rec/tot):    776/   776, tx:     622833, lsn: 0/3A31E5D8, prev 0/3A31E5A0, desc: SPLIT_R level: 0, firstrightoff: 207, newitemoff: 236, postingoff: 0, blkref #0: rel 1663/24605/2658 blk 15, blkref #1: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     61/   465, tx:     622833, lsn: 0/3A31E8E0, prev 0/3A31E5D8, desc: INSERT_UPPER off: 15, blkref #0: rel 1663/24605/2658 blk 3 FPW, blkref #1: rel 1663/24605/2658 blk 15
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31EAB8, prev 0/3A31E8E0, desc: INSERT_LEAF off: 228, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31EAF8, prev 0/3A31EAB8, desc: INSERT_LEAF off: 29, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31EB40, prev 0/3A31EAF8, desc: INSERT_LEAF off: 229, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Heap2       len (rec/tot):    806/   806, tx:     622833, lsn: 0/3A31EB80, prev 0/3A31EB40, desc: MULTI_INSERT ntuples: 6, flags: 0x02, offsets: [38, 39, 40, 41, 42, 43], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31EEA8, prev 0/3A31EB80, desc: INSERT_LEAF off: 32, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31EEF0, prev 0/3A31EEA8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31EF30, prev 0/3A31EEF0, desc: INSERT_LEAF off: 33, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31EF78, prev 0/3A31EF30, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31EFB8, prev 0/3A31EF78, desc: INSERT_LEAF off: 32, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F000, prev 0/3A31EFB8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31F040, prev 0/3A31F000, desc: INSERT_LEAF off: 34, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F088, prev 0/3A31F040, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31F0C8, prev 0/3A31F088, desc: INSERT_LEAF off: 32, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F110, prev 0/3A31F0C8, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31F150, prev 0/3A31F110, desc: INSERT_LEAF off: 35, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F198, prev 0/3A31F150, desc: INSERT_LEAF off: 227, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Storage     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A31F1D8, prev 0/3A31F198, desc: CREATE base/24605/24634
rmgr: Standby     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A31F208, prev 0/3A31F1D8, desc: LOCK xid 622833 db 24605 rel 24634 
rmgr: Heap        len (rec/tot):    203/   203, tx:     622833, lsn: 0/3A31F238, prev 0/3A31F208, desc: INSERT off: 42, flags: 0x00, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F308, prev 0/3A31F238, desc: INSERT_LEAF off: 127, blkref #0: rel 1663/24605/2662 blk 2
rmgr: Btree       len (rec/tot):     88/    88, tx:     622833, lsn: 0/3A31F348, prev 0/3A31F308, desc: INSERT_LEAF off: 12, blkref #0: rel 1663/24605/2663 blk 2
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F3A0, prev 0/3A31F348, desc: INSERT_LEAF off: 291, blkref #0: rel 1663/24605/3455 blk 1
rmgr: Heap2       len (rec/tot):    302/   302, tx:     622833, lsn: 0/3A31F3E0, prev 0/3A31F3A0, desc: MULTI_INSERT ntuples: 2, flags: 0x02, offsets: [44, 45], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31F510, prev 0/3A31F3E0, desc: INSERT_LEAF off: 38, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F558, prev 0/3A31F510, desc: INSERT_LEAF off: 236, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A31F598, prev 0/3A31F558, desc: INSERT_LEAF off: 39, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A31F5E0, prev 0/3A31F598, desc: INSERT_LEAF off: 237, blkref #0: rel 1663/24605/2659 blk 10
rmgr: Heap        len (rec/tot):     54/  8182, tx:     622833, lsn: 0/3A31F620, prev 0/3A31F5E0, desc: INSERT off: 4, flags: 0x01, blkref #0: rel 1663/24605/2610 blk 2 FPW
rmgr: Btree       len (rec/tot):     53/  3137, tx:     622833, lsn: 0/3A321630, prev 0/3A31F620, desc: INSERT_LEAF off: 113, blkref #0: rel 1663/24605/2678 blk 1 FPW
rmgr: Btree       len (rec/tot):     53/  3453, tx:     622833, lsn: 0/3A322290, prev 0/3A321630, desc: INSERT_LEAF off: 168, blkref #0: rel 1663/24605/2679 blk 1 FPW
rmgr: Heap2       len (rec/tot):    121/   121, tx:     622833, lsn: 0/3A323010, prev 0/3A322290, desc: MULTI_INSERT ntuples: 2, flags: 0x02, offsets: [111, 112], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     60/    60, tx:     622833, lsn: 0/3A323090, prev 0/3A323010, desc: DEDUP nintervals: 3, blkref #0: rel 1663/24605/2673 blk 8
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A3230D0, prev 0/3A323090, desc: INSERT_LEAF off: 289, blkref #0: rel 1663/24605/2673 blk 8
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A323118, prev 0/3A3230D0, desc: INSERT_LEAF off: 118, blkref #0: rel 1663/24605/2674 blk 7
rmgr: Btree       len (rec/tot):   3613/ 11253, tx:     622833, lsn: 0/3A323160, prev 0/3A323118, desc: SPLIT_R level: 0, firstrightoff: 147, newitemoff: 290, postingoff: 0, blkref #0: rel 1663/24605/2673 blk 8, blkref #1: rel 1663/24605/2673 blk 9, blkref #2: rel 1663/24605/2673 blk 5 FPW
rmgr: Btree       len (rec/tot):     61/   253, tx:     622833, lsn: 0/3A325D70, prev 0/3A323160, desc: INSERT_UPPER off: 6, blkref #0: rel 1663/24605/2673 blk 3 FPW, blkref #1: rel 1663/24605/2673 blk 8
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A325E70, prev 0/3A325D70, desc: INSERT_LEAF off: 119, blkref #0: rel 1663/24605/2674 blk 7
rmgr: XLOG        len (rec/tot):     49/   137, tx:     622833, lsn: 0/3A325EB8, prev 0/3A325E70, desc: FPI , blkref #0: rel 1663/24605/24634 blk 0 FPW
rmgr: Heap        len (rec/tot):    188/   188, tx:     622833, lsn: 0/3A325F48, prev 0/3A325EB8, desc: INPLACE off: 40, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Heap        len (rec/tot):    188/   188, tx:     622833, lsn: 0/3A326020, prev 0/3A325F48, desc: INPLACE off: 42, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Heap        len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A3260E0, prev 0/3A326020, desc: HOT_UPDATE old_xmax: 622833, old_off: 38, old_infobits: [], flags: 0x60, new_xmax: 0, new_off: 43, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A326130, prev 0/3A3260E0, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [113], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A326188, prev 0/3A326130, desc: INSERT_LEAF off: 144, blkref #0: rel 1663/24605/2673 blk 9
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A3261D0, prev 0/3A326188, desc: INSERT_LEAF off: 118, blkref #0: rel 1663/24605/2674 blk 7
rmgr: XLOG        len (rec/tot):     49/  5389, tx:     622833, lsn: 0/3A326218, prev 0/3A3261D0, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2664 blk 1 FPW
rmgr: Storage     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A327728, prev 0/3A326218, desc: CREATE base/24605/24635
rmgr: Standby     len (rec/tot):     42/    42, tx:     622833, lsn: 0/3A327758, prev 0/3A327728, desc: LOCK xid 622833 db 24605 rel 24635 
rmgr: Heap        len (rec/tot):    203/   203, tx:     622833, lsn: 0/3A327788, prev 0/3A327758, desc: INSERT off: 44, flags: 0x00, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A327858, prev 0/3A327788, desc: INSERT_LEAF off: 128, blkref #0: rel 1663/24605/2662 blk 2
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A327898, prev 0/3A327858, desc: INSERT_LEAF off: 133, blkref #0: rel 1663/24605/2663 blk 2
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A3278E8, prev 0/3A327898, desc: INSERT_LEAF off: 292, blkref #0: rel 1663/24605/3455 blk 1
rmgr: Heap2       len (rec/tot):    176/   176, tx:     622833, lsn: 0/3A327928, prev 0/3A3278E8, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [46], blkref #0: rel 1663/24605/1249 blk 57
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A3279D8, prev 0/3A327928, desc: INSERT_LEAF off: 40, blkref #0: rel 1663/24605/2658 blk 16
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A327A18, prev 0/3A3279D8, desc: INSERT_LEAF off: 238, blkref #0: rel 1663/24605/2659 blk 10
rmgr: XLOG        len (rec/tot):     49/  8241, tx:     622833, lsn: 0/3A327A58, prev 0/3A327A18, desc: FPI_FOR_HINT , blkref #0: rel 1663/24605/2610 fork fsm blk 2 FPW
rmgr: Heap        len (rec/tot):     54/  6358, tx:     622833, lsn: 0/3A329AA8, prev 0/3A327A58, desc: INSERT off: 50, flags: 0x01, blkref #0: rel 1663/24605/2610 blk 3 FPW
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A32B398, prev 0/3A329AA8, desc: INSERT_LEAF off: 113, blkref #0: rel 1663/24605/2678 blk 1
rmgr: Btree       len (rec/tot):     64/    64, tx:     622833, lsn: 0/3A32B3D8, prev 0/3A32B398, desc: INSERT_LEAF off: 169, blkref #0: rel 1663/24605/2679 blk 1
rmgr: Heap        len (rec/tot):    189/   189, tx:     622833, lsn: 0/3A32B418, prev 0/3A32B3D8, desc: INSERT off: 16, flags: 0x00, blkref #0: rel 1663/24605/2606 blk 2
rmgr: Btree       len (rec/tot):     53/  2373, tx:     622833, lsn: 0/3A32B4D8, prev 0/3A32B418, desc: INSERT_LEAF off: 114, blkref #0: rel 1663/24605/2579 blk 1 FPW
rmgr: Btree       len (rec/tot):     80/    80, tx:     622833, lsn: 0/3A32BE20, prev 0/3A32B4D8, desc: INSERT_LEAF off: 113, blkref #0: rel 1663/24605/2664 blk 1
rmgr: Btree       len (rec/tot):     53/  5877, tx:     622833, lsn: 0/3A32BE70, prev 0/3A32BE20, desc: INSERT_LEAF off: 114, blkref #0: rel 1663/24605/2665 blk 1 FPW
rmgr: Btree       len (rec/tot):     53/  2373, tx:     622833, lsn: 0/3A32D580, prev 0/3A32BE70, desc: INSERT_LEAF off: 112, blkref #0: rel 1663/24605/2666 blk 1 FPW
rmgr: Btree       len (rec/tot):     53/  2373, tx:     622833, lsn: 0/3A32DEC8, prev 0/3A32D580, desc: INSERT_LEAF off: 114, blkref #0: rel 1663/24605/2667 blk 1 FPW
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A32E828, prev 0/3A32DEC8, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [114], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A32E880, prev 0/3A32E828, desc: INSERT_LEAF off: 5, blkref #0: rel 1663/24605/2673 blk 5
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A32E8C8, prev 0/3A32E880, desc: INSERT_LEAF off: 119, blkref #0: rel 1663/24605/2674 blk 7
rmgr: Heap2       len (rec/tot):     85/    85, tx:     622833, lsn: 0/3A32E910, prev 0/3A32E8C8, desc: MULTI_INSERT ntuples: 1, flags: 0x02, offsets: [115], blkref #0: rel 1663/24605/2608 blk 12
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A32E968, prev 0/3A32E910, desc: INSERT_LEAF off: 147, blkref #0: rel 1663/24605/2673 blk 9
rmgr: Btree       len (rec/tot):     72/    72, tx:     622833, lsn: 0/3A32E9B0, prev 0/3A32E968, desc: INSERT_LEAF off: 123, blkref #0: rel 1663/24605/2674 blk 7
rmgr: XLOG        len (rec/tot):     49/   137, tx:     622833, lsn: 0/3A32E9F8, prev 0/3A32E9B0, desc: FPI , blkref #0: rel 1663/24605/24635 blk 0 FPW
rmgr: Heap        len (rec/tot):    188/   188, tx:     622833, lsn: 0/3A32EA88, prev 0/3A32E9F8, desc: INPLACE off: 43, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Heap        len (rec/tot):    188/   188, tx:     622833, lsn: 0/3A32EB48, prev 0/3A32EA88, desc: INPLACE off: 44, blkref #0: rel 1663/24605/1259 blk 5
rmgr: Transaction len (rec/tot):   1333/  1333, tx:     622833, lsn: 0/3A32EC08, prev 0/3A32EB48, desc: COMMIT 2025-11-14 12:38:32.188363 MSK; inval msgs: catcache 80 catcache 79 catcache 80 catcache 79 catcache 55 catcache 54 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 55 catcache 54 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 7 catcache 6 catcache 55 catcache 54 catcache 7 catcache 6 catcache 7 catcache 6 catcache 32 catcache 55 catcache 54 catcache 55 catcache 54 catcache 55 catcache 54 catcache 55 catcache 54 catcache 7 catcache 6 catcache 32 catcache 19 catcache 55 catcache 54 catcache 55 catcache 54 snapshot 2608 relcache 24630 relcache 24633 relcache 24634 relcache 24633 snapshot 2608 relcache 24633 relcache 24634 relcache 24630 snapshot 2608 relcache 24635 relcache 24630 snapshot 2608 relcache 24630 relcache 24635
rmgr: Heap2       len (rec/tot):     59/    59, tx:          0, lsn: 0/3A32F140, prev 0/3A32EC08, desc: PRUNE snapshotConflictHorizon: 0, nredirected: 1, ndead: 0, nunused: 0, redirected: [38->43], dead: [], unused: [], blkref #0: rel 1663/24605/1259 blk 5
rmgr: Heap        len (rec/tot):     61/    61, tx:     622834, lsn: 0/3A32F180, prev 0/3A32F140, desc: INSERT+INIT off: 1, flags: 0x00, blkref #0: rel 1663/24605/24630 blk 0
rmgr: Btree       len (rec/tot):     90/    90, tx:     622834, lsn: 0/3A32F1C0, prev 0/3A32F180, desc: NEWROOT level: 0, blkref #0: rel 1663/24605/24635 blk 1, blkref #2: rel 1663/24605/24635 blk 0
rmgr: Btree       len (rec/tot):     64/    64, tx:     622834, lsn: 0/3A32F220, prev 0/3A32F1C0, desc: INSERT_LEAF off: 1, blkref #0: rel 1663/24605/24635 blk 1
rmgr: Heap        len (rec/tot):     61/    61, tx:     622834, lsn: 0/3A32F260, prev 0/3A32F220, desc: INSERT off: 2, flags: 0x00, blkref #0: rel 1663/24605/24630 blk 0
rmgr: Btree       len (rec/tot):     64/    64, tx:     622834, lsn: 0/3A32F2A0, prev 0/3A32F260, desc: INSERT_LEAF off: 2, blkref #0: rel 1663/24605/24635 blk 1
rmgr: Heap        len (rec/tot):     61/    61, tx:     622834, lsn: 0/3A32F2E0, prev 0/3A32F2A0, desc: INSERT off: 3, flags: 0x00, blkref #0: rel 1663/24605/24630 blk 0
rmgr: Btree       len (rec/tot):     64/    64, tx:     622834, lsn: 0/3A32F320, prev 0/3A32F2E0, desc: INSERT_LEAF off: 3, blkref #0: rel 1663/24605/24635 blk 1
rmgr: Heap        len (rec/tot):     61/    61, tx:     622834, lsn: 0/3A32F360, prev 0/3A32F320, desc: INSERT off: 4, flags: 0x00, blkref #0: rel 1663/24605/24630 blk 0
rmgr: Btree       len (rec/tot):     64/    64, tx:     622834, lsn: 0/3A32F3A0, prev 0/3A32F360, desc: INSERT_LEAF off: 4, blkref #0: rel 1663/24605/24635 blk 1
rmgr: Heap        len (rec/tot):     61/    61, tx:     622834, lsn: 0/3A32F3E0, prev 0/3A32F3A0, desc: INSERT off: 5, flags: 0x00, blkref #0: rel 1663/24605/24630 blk 0
rmgr: Btree       len (rec/tot):     64/    64, tx:     622834, lsn: 0/3A32F420, prev 0/3A32F3E0, desc: INSERT_LEAF off: 5, blkref #0: rel 1663/24605/24635 blk 1
rmgr: Transaction len (rec/tot):     34/    34, tx:     622834, lsn: 0/3A32F460, prev 0/3A32F420, desc: COMMIT 2025-11-14 12:38:36.262604 MSK
```

**Выводы и объяснения:**
1. Значительная часть объёма идёт от записей XLOG ... FPI_FOR_HINT ... FPW и других FPW‑записей: это полные образы страниц (full page writes), которые логируются при первом изменении страницы после контрольной точки для защиты от частичных записей, и каждая такая запись добавляет в WAL по 8 кБ на страницу.
2. Помимо прямых вставок в heap (Heap INSERT/MULTI_INSERT) в журнал попадает много Btree INSERT_LEAF, SPLIT_R, NEWROOT и Storage CREATE записей, связанных с созданием и ростом индексов и служебных структур, плюс крупные Transaction COMMIT с инвалидациями кэша, поэтому итоговый объём WAL отражает не только пять вставленных строк, а целый комплекс внутренних операций по созданию и перестройке структуры хранения.
​
#### Задача 3: Восстановление после сбоя

**Цель:** Продемонстрировать, что после аварийного завершения процесса сервера PostgreSQL восстанавливает состояние по WAL, сохраняя только зафиксированные изменения и откатывая незавершённые транзакции.

**Выполненные действия:**

```bash
ps aux | grep "postgres"
sudo kill -9 244511
sudo -u student /home/student/pgsql16/bin/pg_ctl -D /home/student/pgsql16/data -l logfile start
psql -U postgres -d lab05
```

```sql
SELECT * FROM wal_lsn_test WHERE id = 20;
```

```bash
sudo tail -n 50 logfile
```

**Результаты:**
```bash
student   244511  0.1  0.5 203136 21488 ?        Ss   13:00   0:00 /home/student/pgsql16/bin/postgres -D /home/student/pgsql16/data
student   244512  0.0  0.1 203268  5712 ?        Ss   13:00   0:00 postgres: checkpointer 
student   244513  0.0  0.1 203292  4364 ?        Ss   13:00   0:00 postgres: background writer 
student   244515  0.0  0.1 203136  7512 ?        Ss   13:00   0:00 postgres: walwriter 
student   244516  0.1  0.1 204736  6172 ?        Ss   13:00   0:00 postgres: autovacuum launcher 
student   244517  0.0  0.1 204716  5200 ?        Ss   13:00   0:00 postgres: logical replication launcher

 id | data 
----+------
(0 rows)

2025-11-14 11:49:43.285 MSK [244511] LOG:  listening on IPv4 address "127.0.0.1", port 5555
2025-11-14 11:49:43.294 MSK [244511] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5555"
2025-11-14 11:49:43.304 MSK [244514] LOG:  database system was shut down at 2025-11-14 11:49:43 MSK
2025-11-14 11:49:43.313 MSK [244511] LOG:  database system is ready to accept connections
2025-11-14 11:49:45.801 MSK [244528] FATAL:  role "student" does not exist
2025-11-14 11:54:43.337 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 11:54:43.366 MSK [244512] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.003 s, total=0.030 s; sync files=2, longest=0.002 s, average=0.002 s; distance=0 kB, estimate=0 kB; lsn=0/3992FD38, redo lsn=0/3992FD00
2025-11-14 12:02:22.273 MSK [247551] LOG:  automatic vacuum of table "lab05.public.wal_test": index scans: 0
	pages: 0 removed, 715 remain, 715 scanned (100.00% of total)
	tuples: 0 removed, 5000 remain, 0 are dead but not yet removable
	removable cutoff: 622827, which was 0 XIDs old when operation ended
	new relfrozenxid: 622826, which is 1 XIDs ahead of previous value
	frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
	index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
	avg read rate: 0.000 MB/s, avg write rate: 0.908 MB/s
	buffer usage: 1448 hits, 0 misses, 3 dirtied
	WAL usage: 718 records, 3 full page images, 67052 bytes
	system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.02 s
2025-11-14 12:02:22.300 MSK [247551] LOG:  automatic analyze of table "lab05.public.wal_test"
	avg read rate: 0.651 MB/s, avg write rate: 0.000 MB/s
	buffer usage: 888 hits, 2 misses, 0 dirtied
	system usage: CPU: user: 0.00 s, system: 0.01 s, elapsed: 0.02 s
2025-11-14 12:02:26.850 MSK [244512] LOG:  checkpoint starting: immediate force wait
2025-11-14 12:02:27.219 MSK [244512] LOG:  checkpoint complete: wrote 1654 buffers (10.1%); 0 WAL file(s) added, 1 removed, 0 recycled; write=0.110 s, sync=0.228 s, total=0.370 s; sync files=306, longest=0.004 s, average=0.001 s; distance=9581 kB, estimate=9581 kB; lsn=0/3A28B328, redo lsn=0/3A28B2F0
2025-11-14 12:07:26.288 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 12:07:31.063 MSK [244512] LOG:  checkpoint complete: wrote 44 buffers (0.3%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.703 s, sync=0.044 s, total=4.776 s; sync files=34, longest=0.008 s, average=0.002 s; distance=221 kB, estimate=8645 kB; lsn=0/3A2C27A8, redo lsn=0/3A2C2770
2025-11-14 12:07:38.658 MSK [244512] LOG:  checkpoint starting: immediate force wait
2025-11-14 12:07:38.683 MSK [244512] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.025 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=7780 kB; lsn=0/3A2C2890, redo lsn=0/3A2C2858
2025-11-14 12:12:38.787 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 12:12:40.773 MSK [244512] LOG:  checkpoint complete: wrote 20 buffers (0.1%); 0 WAL file(s) added, 0 removed, 0 recycled; write=1.938 s, sync=0.024 s, total=1.986 s; sync files=16, longest=0.011 s, average=0.002 s; distance=101 kB, estimate=7012 kB; lsn=0/3A2DBE10, redo lsn=0/3A2DBDD8
2025-11-14 12:33:03.138 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 12:33:03.377 MSK [244512] LOG:  checkpoint complete: wrote 2 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.211 s, sync=0.008 s, total=0.239 s; sync files=2, longest=0.006 s, average=0.004 s; distance=9 kB, estimate=6312 kB; lsn=0/3A2DE210, redo lsn=0/3A2DE1D8
2025-11-14 12:36:46.468 MSK [255765] WARNING:  there is no transaction in progress
2025-11-14 12:38:03.480 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 12:38:06.949 MSK [244512] LOG:  checkpoint complete: wrote 33 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.410 s, sync=0.034 s, total=3.470 s; sync files=30, longest=0.008 s, average=0.002 s; distance=140 kB, estimate=5695 kB; lsn=0/3A301248, redo lsn=0/3A301210
2025-11-14 12:38:40.857 MSK [256369] WARNING:  there is no transaction in progress
2025-11-14 12:43:04.049 MSK [244512] LOG:  checkpoint starting: time
2025-11-14 12:43:08.317 MSK [244512] LOG:  checkpoint complete: wrote 40 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=4.208 s, sync=0.034 s, total=4.269 s; sync files=30, longest=0.011 s, average=0.002 s; distance=184 kB, estimate=5144 kB; lsn=0/3A32F4F8, redo lsn=0/3A32F4C0
2025-11-14 13:00:25.688 MSK [262384] FATAL:  terminating connection due to unexpected postmaster exit
2025-11-14 13:00:46.915 MSK [262926] LOG:  starting PostgreSQL 16.0 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit
2025-11-14 13:00:46.916 MSK [262926] LOG:  listening on IPv4 address "127.0.0.1", port 5555
2025-11-14 13:00:46.926 MSK [262926] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5555"
2025-11-14 13:00:46.937 MSK [262929] LOG:  database system was interrupted; last known up at 2025-11-14 12:43:08 MSK
2025-11-14 13:00:48.159 MSK [262929] LOG:  database system was not properly shut down; automatic recovery in progress
2025-11-14 13:00:48.165 MSK [262929] LOG:  redo starts at 0/3A32F4C0
2025-11-14 13:00:48.165 MSK [262929] LOG:  invalid record length at 0/3A32F898: expected at least 24, got 0
2025-11-14 13:00:48.165 MSK [262929] LOG:  redo done at 0/3A32F860 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
2025-11-14 13:00:48.174 MSK [262927] LOG:  checkpoint starting: end-of-recovery immediate wait
2025-11-14 13:00:48.204 MSK [262927] LOG:  checkpoint complete: wrote 5 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.007 s, sync=0.008 s, total=0.035 s; sync files=4, longest=0.004 s, average=0.002 s; distance=0 kB, estimate=0 kB; lsn=0/3A32F898, redo lsn=0/3A32F898
2025-11-14 13:00:48.209 MSK [262926] LOG:  database system is ready to accept connections
```

**Выводы и объяснения:**
В таблице wal_lsn_test строка с id = 20 отсутствует, значит вставка либо не была выполнена, либо не была зафиксирована до аварийного завершения, и при восстановлении сервер не применил эти изменения, как и полагается для незаконченной транзакции.​
В журнале видно, что база "была прервана" и "завершена некорректно", после чего запущено автоматическое восстановление по WAL (automatic recovery in progress), выполняется чтение и применение записей (redo starts at ..., redo done at ...), затем выполняется контрольная точка end-of-recovery, и только после этого система объявляет себя готовой принимать подключения, что подтверждает работу механизма журналирования и восстановления после сбоя.​

### Модуль 4: Настройка WAL

#### Задача 1: Влияние full_page_writes

**Цель:** Исследовать, как параметр full_page_writes влияет на объём генерируемого WAL при одной и той же нагрузке записи (pgbench).

**Выполненные действия:**

```sql
-- 1. Для чистоты эксперимента: принудительная контрольная точка
CHECKPOINT;

-- 2. Зафиксировать текущий LSN
SELECT pg_current_wal_lsn();
```

```bash
# 3. Запустить простую нагрузку записи (пример с pgbench)
pgbench -i -s 1 -U postgres lab05

# Нагрузка: например, 1000 транзакций одним клиентом
pgbench -U postgres -d lab05 -c 1 -t 1000
```

```sql
-- 4. Измерить объём WAL при full_page_writes = on
SELECT
    pg_current_wal_lsn() - '0/3B81ED00'::pg_lsn AS wal_bytes_raw_on,
    pg_size_pretty(pg_current_wal_lsn() - '0/3B81ED00'::pg_lsn) AS wal_bytes_pretty_on;
```

```sql
-- 5. Для чистоты эксперимента: принудительная контрольная точка
CHECKPOINT;

-- 6. Зафиксировать текущий LSN
SELECT pg_current_wal_lsn();
```

```bash
# Нагрузка: например, 1000 транзакций одним клиентом
pgbench -U postgres -d lab05 -c 1 -t 1000
```

```sql
-- 8. Измерить объём WAL при full_page_writes = on
SELECT
    pg_current_wal_lsn() - '0/3C55C9C8'::pg_lsn AS wal_bytes_raw_on,
    pg_size_pretty(pg_current_wal_lsn() - '0/3C55C9C8'::pg_lsn) AS wal_bytes_pretty_on;
```

**Результаты:**

```bash
pg_current_wal_lsn 
--------------------
 0/3B81ED00
(1 row)

transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 1000/1000
number of failed transactions: 0 (0.000%)
latency average = 8.734 ms
initial connection time = 2.944 ms
tps = 114.491944 (without initial connection time)

wal_bytes_raw_on | wal_bytes_pretty_on 
------------------+---------------------
         13884064 | 13 MB
(1 row)

pg_current_wal_lsn 
--------------------
 0/3C55C9C8
(1 row)

transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 1000/1000
number of failed transactions: 0 (0.000%)
latency average = 8.997 ms
initial connection time = 5.256 ms
tps = 111.151817 (without initial connection time)

wal_bytes_raw_off | wal_bytes_pretty_off 
-------------------+----------------------
           1034896 | 1011 kB
(1 row)
```

**Выводы и объяснения:**
При full_page_writes = on PostgreSQL при первом изменении каждой страницы после контрольной точки пишет в WAL полный образ 8‑килобайтной страницы, поэтому для 1000 транзакций объём журнала получился около 13 MB.​
При full_page_writes = off полные образы страниц не записываются, и в журнал попадают только более компактные логические записи об изменениях строк и индексов, поэтому объём WAL для той же нагрузки снижается примерно до 1 MB, что демонстрирует сильное влияние этого параметра на размер журнала, но при этом уменьшает устойчивость к повреждению страниц при сбоях.

#### Задача 2: Эффективность сжатия WAL

**Цель:** Оценить, как параметр wal_compression влияет на объём генерируемого WAL при одинаковой нагрузке pgbench и во сколько раз уменьшается размер журнала.

**Выполненные действия:**
```sql
-- 1. Включить full_page_writes, чтобы были полные образы страниц
ALTER SYSTEM SET full_page_writes = on;
SELECT pg_reload_conf();

-- 2. Отключить сжатие WAL
ALTER SYSTEM SET wal_compression = off;
SELECT pg_reload_conf();

-- 3. Контрольная точка и начальный LSN
CHECKPOINT;
SELECT pg_current_wal_lsn();
```

```bash
# 4. Нагрузка pgbench (та же, что в задаче 1)
pgbench -U postgres -d lab05 -c 1 -t 1000
```

```sql
-- 5. Объём WAL без сжатия
SELECT 
    pg_current_wal_lsn() - '0/3C659648'::pg_lsn AS wal_bytes_raw_off, 
    pg_size_pretty(pg_current_wal_lsn() - '0/3C659648'::pg_lsn) AS wal_bytes_pretty_off;
```

```sql
-- 6. Включить сжатие WAL
ALTER SYSTEM SET wal_compression = on;
SELECT pg_reload_conf();

-- 7. Снова контрольная точка и новый начальный LSN
CHECKPOINT;
SELECT pg_current_wal_lsn();
```

```bash
# 8. Та же нагрузка pgbench
pgbench -U postgres -d lab05 -c 1 -t 1000
```

```sql
-- 9. Объём WAL со сжатием
SELECT
    pg_current_wal_lsn() - '0/3CD85740'::pg_lsn AS wal_bytes_raw_off,
    pg_size_pretty(pg_current_wal_lsn() - '0/3CD85740'::pg_lsn) AS wal_bytes_pretty_off;
```


**Результаты:**

```bash
pg_current_wal_lsn 
--------------------
 0/3C659648
(1 row)

transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 1000/1000
number of failed transactions: 0 (0.000%)
latency average = 8.964 ms
initial connection time = 4.343 ms
tps = 111.562817 (without initial connection time)

wal_bytes_raw_off | wal_bytes_pretty_off 
-------------------+----------------------
           7520328 | 7344 kB

pg_current_wal_lsn 
--------------------
 0/3CD85740
(1 row)

transaction type: <builtin: TPC-B (sort of)>
scaling factor: 1
query mode: simple
number of clients: 1
number of threads: 1
maximum number of tries: 1
number of transactions per client: 1000
number of transactions actually processed: 1000/1000
number of failed transactions: 0 (0.000%)
latency average = 8.652 ms
initial connection time = 3.634 ms
tps = 115.581054 (without initial connection time)

wal_bytes_raw_off | wal_bytes_pretty_off 
-------------------+----------------------
           1443424 | 1410 kB
(1 row)
```

**Выводы и объяснения:**
При wal_compression = off полный объём WAL для 1000 транзакций составил примерно 7,3 MB, так как полные образы страниц (full page images) записываются без сжатия.​
При включённом wal_compression = on объём WAL для той же нагрузки снизился до примерно 1,4 MB (сжатие примерно в 5,2 раза), потому что полные образы страниц в журнале сжимаются, что существенно экономит место в WAL и архивах при некотором росте нагрузки на CPU.
Основная часть лабы уже хорошо структурирована, осталось привести формулировки к теме WAL и текущего модуля. Ниже — готовый блок для отчёта в стиле предыдущих модулей.

## Результаты выполнения

### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅Выполнено | Найдены фоновые процессы PostgreSQL, отвечающие за буферный кеш (checkpointer, background writer) и запись WAL (walwriter). |
| 1 | 2 | ✅Выполнено | При fast‑остановке выполняется контрольная точка типа shutdown, поэтому при следующем запуске recovery не требуется. |
| 1 | 3 | ✅Выполнено | При аварийной остановке (kill -9) при старте запускается автоматическое восстановление по WAL (redo), после чего выполняется контрольная точка end-of-recovery. |
| 2 | 1 | ✅Выполнено | Определены размер таблицы wal_test на диске (в страницах) и количество её буферов в кешe через pg_buffercache. |
| 2 | 2 | ✅Выполнено | В момент эксперимента число "грязных" буферов было равно нулю и не изменилось после CHECKPOINT, так как все изменённые страницы уже были записаны на диск. |
| 2 | 3 | ✅Выполнено | Предзагрузка таблицы с помощью pg_prewarm показала, что кеш уже был прогрет, а после рестарта количество буферов для таблицы не изменилось. |
| 3 | 1 | ✅Выполнено | Для небольшой транзакции с созданием таблицы и INSERT нескольких строк сгенерировано заметное количество WAL за счёт структурных изменений и полных образов страниц. |
| 3 | 2 | ✅Выполнено | Анализ WAL через pg_waldump показал наличие FPI/FPW‑записей, множества heap/btree‑операций и крупных COMMIT‑записей, объясняющих большой объём журнала. |
| 3 | 3 | ✅Выполнено | При аварийном завершении сервера зафиксированные изменения сохраняются, а незавершённые транзакции откатываются во время восстановления по WAL. |
| 4 | 1 | ✅Выполнено | Показано, что включённый full_page_writes существенно увеличивает объём WAL, а его отключение уменьшает размер журнала для той же нагрузки. |
| 4 | 2 | ✅Выполнено | Включение wal_compression при full_page_writes = on уменьшает размер WAL примерно в 5 раз за счёт сжатия полных образов страниц. |

## Анализ и выводы

### Основные наблюдения

1. Фоновые процессы checkpointer, background writer и walwriter совместно обеспечивают сброс изменённых страниц на диск и надёжную запись WAL, что позволяет ограничивать объём необходимого для восстановления журнала и снижать задержки при коммитах.  

2. Fast‑остановка инициирует контрольную точку и завершает работу "чисто", тогда как аварийное завершение приводит к запуску автоматического восстановления по WAL (redo) при следующем старте.  

3. Буферный кеш может содержать как "чистые", так и "грязные" страницы; CHECKPOINT снижает количество грязных буферов, а в моменты, когда фоновые процессы уже успели всё сбросить, число грязных страниц остаётся нулевым.  

4. Объём WAL зависит не только от количества данных, но и от структурных операций (CREATE, индексы), параметра full_page_writes и наличия FPI/FPW‑записей; сжатие WAL (wal_compression) позволяет значительно уменьшить размер журнала за счёт компрессии полных образов страниц.

### Сравнительный анализ

#### Поведение при разных режимах остановки и сбоях

- Fast‑остановка сопровождается явной контрольной точкой, после чего при запуске база считается корректно завершённой и recovery не требуется.  

- Аварийное завершение (kill -9 postmaster) оставляет систему в некорректном состоянии, и при старте сервер выполняет автоматическое восстановление по WAL, воспроизводя только зафиксированные изменения и откатывая незавершённые транзакции.

#### Влияние настроек WAL на объём журнала

- При full_page_writes = on даже относительно небольшие операции могут порождать крупный объём WAL из‑за записи полных 8‑килобайтных образов страниц после контрольной точки.  

- Отключение full_page_writes и включение wal_compression заметно сокращают объём WAL для одинаковой нагрузки, однако уменьшают запас надёжности при сбоях, поэтому в реальных системах эти параметры нужно настраивать с учётом требований к устойчивости и скорости восстановления.
