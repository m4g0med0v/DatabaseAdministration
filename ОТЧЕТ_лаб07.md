# Отчет по лабораторной работе №7  
# Управление доступом, расширениями и локализацией

## Сведения о студенте

**Дата:** 30.11.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович  

## Цель работы

Освоение механизмов управления доступом в PostgreSQL, включая систему ролей и привилегий, настройку аутентификации через файл pg_hba.conf, а также получение практических навыков работы с расширениями и параметрами локализации (кодировки, правила сортировки и форматы даты/времени).

## Теоретическая часть

### Изученные концепции

- **Роли и привилегии:** Роли в PostgreSQL объединяют функции пользователей и групп; им можно назначать привилегии на базы данных, схемы, таблицы и другие объекты с помощью команд GRANT и REVOKE.

- **Аутентификация (pg_hba.conf):** Доступ клиентов определяется записями в файле pg_hba.conf, где задаются тип подключения, адреса хостов, пользователи, базы данных и метод аутентификации (trust, md5, scram-sha-256 и др.). 

- **Расширения (CREATE EXTENSION):** Расширения позволяют подключать дополнительный функционал (типы данных, функции, операторы) единым пакетом; установка выполняется командой CREATE EXTENSION в нужной базе данных. 

- **Локализация и сортировка (collation):** Параметры локали и collation определяют правила сортировки строк и сравнения текстов, зависят от используемого провайдера (OS или ICU) и выбираются при инициализации кластера или создании объектов.

- **Кодировки:** Кодировка базы данных и клиентская кодировка влияют на хранение и отображение текста; для миграции между различными кодировками часто используют дамп и восстановление (pg_dump/pg_restore) с указанием нужной encoding.

### Ключевые термины

- **Роль (ROLE):** Логический субъект в PostgreSQL, который может обладать правами входа, владеть объектами и иметь привилегии; роль может представлять как пользователя, так и группу. 

- **Привилегия (GRANT/REVOKE):** Разрешение на выполнение операций над объектами БД (SELECT, INSERT, UPDATE, DELETE, USAGE, EXECUTE и др.), которое можно выдать или отозвать у ролей.  

- **pg_hba.conf:** Конфигурационный файл, определяющий правила аутентификации для различных типов подключений (local, host и т.д.), сетей и методов проверки подлинности.  

- **Расширение (EXTENSION):** Устанавливаемый пакет объектов базы данных (функции, операторы, типы), которым централизованно управляет PostgreSQL через CREATE EXTENSION и DROP EXTENSION.

- **Collation (правила сортировки):** Настройка, задающая порядок сортировки и сравнения строк для конкретной базы данных, колонки или выражения; может отличаться от общей локали системы.

## Практическая часть

### Модуль 1: Управление доступом

#### Задача 1: Базовые привилегии

**Цель:** Настроить базовую модель управления доступом в PostgreSQL с использованием групповых ролей и привилегий, чтобы роль writer имела полный доступ к таблицам в схеме public, а роль reader - только права на чтение, включая автоматическое предоставление прав на новые таблицы, создаваемые writer.

**Выполненные действия:**

```sql
-- 1. Создание базы для эксперимента с доступом
CREATE DATABASE access_db;

-- 2. Создание групповых ролей
CREATE ROLE writer;
CREATE ROLE reader;

-- 3. Создание пользователей и включение их в групповые роли
CREATE ROLE w1 LOGIN PASSWORD 'w1pass' INHERIT;
CREATE ROLE r1 LOGIN PASSWORD 'r1pass' INHERIT;

GRANT writer TO w1;
GRANT reader TO r1;

-- 4. Переход в базу access_db
\c access_db

-- 5. Отзыв привилегий роли public на схему public
REVOKE ALL PRIVILEGES ON SCHEMA public FROM PUBLIC;

-- 6. Выдача прав на схему ролям writer и reader
GRANT USAGE, CREATE ON SCHEMA public TO writer;
GRANT USAGE ON SCHEMA public TO reader;

-- 7. Выдача прав чтения reader на уже существующие таблицы
GRANT SELECT ON ALL TABLES IN SCHEMA public TO reader;

-- 8. Настройка привилегий по умолчанию:
-- новые таблицы в схеме public, создаваемые writer, автоматически доступны reader для SELECT
ALTER DEFAULT PRIVILEGES FOR ROLE writer IN SCHEMA public
    GRANT SELECT ON TABLES TO reader;

ALTER DEFAULT PRIVILEGES FOR ROLE writer IN SCHEMA public
    GRANT SELECT ON SEQUENCES TO reader;

-- 9. Работа под пользователем w1 (роль writer):
-- создание и проверка таблицы
\c access_db w1

CREATE TABLE test_table (
    id   SERIAL PRIMARY KEY,
    data TEXT
);

INSERT INTO test_table (data) VALUES ('row1');
UPDATE test_table SET data = 'row1-upd' WHERE id = 1;
DELETE FROM test_table WHERE id = 1;

-- 10. Проверка под пользователем r1 (роль reader)
\c access_db r1

SELECT * FROM test_table;
INSERT INTO test_table (data) VALUES ('row2');
UPDATE test_table SET data = 'row2-upd' WHERE id = 1;
DELETE FROM test_table WHERE id = 1;
```

**Результаты:**

```bash
# w1
INSERT 0 1
UPDATE 1
DELETE 1

# r1
 id | data 
----+------
(0 rows)
ERROR:  permission denied for table test_table
ERROR:  permission denied for table test_table
ERROR:  permission denied for table test_table
```

**Выводы и объяснения:**

Роль writer получила права USAGE и CREATE на схему public, поэтому её участник w1 может создавать таблицы и выполнять все операции с ними, включая INSERT, UPDATE и DELETE.​

Роль reader имеет только USAGE на схему public и право SELECT, выданное как на уже существующие таблицы (через GRANT SELECT ON ALL TABLES IN SCHEMA public), так и на будущие таблицы writer (через ALTER DEFAULT PRIVILEGES), поэтому пользователь r1 может читать данные из test_table, но не может изменять её содержимое.

### Модуль 2: Управление расширениями

#### Задача 1: Установка расширения

**Цель:** Установить доступное в сборке PostgreSQL расширение и убедиться, что оно отображается в представлениях pg_available_extensions и pg_extension.

**Выполненные действия:**

```sql
-- Установка расширения pg_trgm
CREATE EXTENSION pg_trgm;

-- Проверка через pg_available_extensions
SELECT name, default_version, installed_version
FROM pg_available_extensions
WHERE name = 'pg_trgm';

-- Проверка через pg_extension
SELECT extname, extversion
FROM pg_extension
WHERE extname = 'pg_trgm';
```

**Результаты:**

```bash
CREATE EXTENSION

  name   | default_version | installed_version 
---------+-----------------+-------------------
 pg_trgm | 1.6             | 1.6
(1 row)

 extname | extversion 
---------+------------
 pg_trgm | 1.6
(1 row)
```

**Выводы и объяснения:**

Команда CREATE EXTENSION pg_trgm успешно установила модуль pg_trgm в базе lab07, что подтвердилось появлением установленной версии 1.6 в pg_available_extensions и записи в pg_extension.​

Отсутствие ошибок и совпадение версий в обоих представлениях показывают, что расширение корректно доступно для использования в текущей базе данных.

#### Задача 2: Создание и исследование

**Цель:** Установить расширение без явного указания версии, определить установленную версию и просмотреть, какие версии доступны и могли быть использованы при установке.

**Выполненные действия:**

```sql
-- Попытка создать расширение без указания версии
CREATE EXTENSION pg_trgm;

-- Проверка установленной версии в каталоге расширений
SELECT extname, extversion
FROM pg_extension
WHERE extname = 'pg_trgm';

-- Просмотр всех доступных версий и признака установленной
SELECT *
FROM pg_available_extension_versions
WHERE name = 'pg_trgm';
```

**Результаты:**

```bash
CREATE EXTENSION

 extname | extversion 
---------+------------
 pg_trgm | 1.6
(1 row)

  name   | version | installed | superuser | trusted | relocatable | schema | requires |                              comment                              
---------+---------+-----------+-----------+---------+-------------+--------+----------+-------------------------------------------------------------------
 pg_trgm | 1.3     | f         | t         | t       | t           |        |          | text similarity measurement and index searching based on trigrams
 pg_trgm | 1.4     | f         | t         | t       | t           |        |          | text similarity measurement and index searching based on trigrams
 pg_trgm | 1.5     | f         | t         | t       | t           |        |          | text similarity measurement and index searching based on trigrams
 pg_trgm | 1.6     | t         | t         | t       | t           |        |          | text similarity measurement and index searching based on trigrams
(4 rows)
```

**Выводы и объяснения:**

Команда CREATE EXTENSION pg_trgm без указания версии установила расширение в версии 1.6, что видно по полю extversion в системном каталоге pg_extension.​

Представление pg_available_extension_versions показывает, что для pg_trgm доступны версии 1.3–1.6, при этом установленная версия отмечена installed = t; именно её install‑скрипт (файл с соответствующим номером версии в каталоге расширений) был выполнен при установке.

#### Задача 3: Добавление данных

**Цель:** Создать собственный справочник единиц измерения в базе и добавить в него новые единицы (футы и дюймы).

**Выполненные действия:**

```sql
-- 1. Создаём свой справочник единиц измерения
CREATE TABLE units_of_measure (
    code        text PRIMARY KEY,   -- условное обозначение
    name_ru     text,               -- русское название
    base_unit   text,               -- базовая единица (например, метр)
    factor_to_base numeric          -- коэффициент перевода к базовой единице
);

-- 2. Добавляем базовую единицу (метр)
INSERT INTO units_of_measure (code, name_ru, base_unit, factor_to_base)
VALUES ('m', 'метр', 'm', 1.0);

-- 3. Добавляем футы и дюймы
INSERT INTO units_of_measure (code, name_ru, base_unit, factor_to_base)
VALUES 
    ('ft', 'фут',   'm', 0.3048),   -- 1 фут ≈ 0.3048 м
    ('in', 'дюйм',  'm', 0.0254);   -- 1 дюйм ≈ 0.0254 м

-- 4. Проверяем содержимое справочника
SELECT * FROM units_of_measure ORDER BY code;
```

**Результаты:**

```bash
 code | name_ru | base_unit | factor_to_base 
------+---------+-----------+----------------
 ft   | фут     | m         |         0.3048
 in   | дюйм    | m         |         0.0254
 m    | метр    | m         |            1.0
(3 rows)
```

**Выводы и объяснения:**

Справочник units_of_measure создаёт простую модель, где все длины приводятся к базовой единице "метр" через поле factor_to_base, поэтому добавление футов и дюймов сводится к сохранению их коэффициентов перевода 0.3048 и 0.0254 соответственно.​

Полученный список строк показывает, что все единицы успешно добавлены и могут использоваться для нормализации и конвертации измерений в прикладных запросах.

#### Задача 4: Управление доступом

**Цель:** Ограничить доступ к таблице справочника units_of_measure, убрав право чтения у public и передав его специальной роли ext_reader, чтобы только участники этой роли могли просматривать данные.

**Выполненные действия:**

```sql
-- 1. Создание специальной роли
CREATE ROLE ext_reader;

-- 2. Отзыв права SELECT у PUBLIC на таблицу units_of_measure
REVOKE SELECT ON TABLE units_of_measure FROM PUBLIC;

-- 3. Выдача права SELECT специальной роли ext_reader
GRANT SELECT ON TABLE units_of_measure TO ext_reader;

-- 4. Включение пользователя r1 в роль ext_reader
GRANT ext_reader TO r1;

-- 5. Проверка под пользователем r1
\c lab07 r1
SELECT * FROM units_of_measure;

-- 6. Проверка под пользователем w1
\c lab07 w1
SELECT * FROM units_of_measure;
```

**Результаты:**

```bash
# Для пользователя r1
 code | name_ru | base_unit | factor_to_base 
------+---------+-----------+----------------
 m    | метр    | m         |            1.0
 ft   | фут     | m         |         0.3048
 in   | дюйм    | m         |         0.0254
(3 rows)

# Для пользователя w1
ERROR:  permission denied for table units_of_measure
```

**Выводы и объяснения:**

После REVOKE SELECT FROM PUBLIC таблица units_of_measure перестала быть доступной "по умолчанию" для всех ролей: пользователь w1, не входящий в ext_reader, получает ошибку permission denied при попытке чтения.​

Права SELECT были выданы только роли ext_reader, поэтому пользователь r1, включённый в эту роль, успешно видит все строки из units_of_measure; таким образом, доступ к данным расширения централизованно контролируется через одну специальную роль.

#### Задача 5: Резервное копирование

**Цель:** Выполнить логическое резервное копирование базы lab07 с объектами расширения и пользовательского справочника, затем убедиться по дампу, что выгружаются и метаданные (создание таблиц, типов, функций, расширений), и данные.​

**Выполненные действия:**

```bash
# 1. Выполняем дамп базы lab07
pg_dump -U postgres -d lab07 > lab07_dump.sql
cat lab07_dump.sql
```

**Результаты:**

```bash
--
-- PostgreSQL database dump
--

-- Dumped from database version 16.0
-- Dumped by pg_dump version 16.0

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- Name: pg_trgm; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS pg_trgm WITH SCHEMA public;


--
-- Name: EXTENSION pg_trgm; Type: COMMENT; Schema: -; Owner: 
--

COMMENT ON EXTENSION pg_trgm IS 'text similarity measurement and index searching based on trigrams';


SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: units_of_measure; Type: TABLE; Schema: public; Owner: postgres
--

CREATE TABLE public.units_of_measure (
    code text NOT NULL,
    name_ru text,
    base_unit text,
    factor_to_base numeric
);


ALTER TABLE public.units_of_measure OWNER TO postgres;

--
-- Data for Name: units_of_measure; Type: TABLE DATA; Schema: public; Owner: postgres
--

COPY public.units_of_measure (code, name_ru, base_unit, factor_to_base) FROM stdin;
m	метр	m	1.0
ft	фут	m	0.3048
in	дюйм	m	0.0254
\.


--
-- Name: units_of_measure units_of_measure_pkey; Type: CONSTRAINT; Schema: public; Owner: postgres
--

ALTER TABLE ONLY public.units_of_measure
    ADD CONSTRAINT units_of_measure_pkey PRIMARY KEY (code);


--
-- Name: TABLE units_of_measure; Type: ACL; Schema: public; Owner: postgres
--

GRANT SELECT ON TABLE public.units_of_measure TO ext_reader;


--
-- PostgreSQL database dump complete
--
```

**Выводы и объяснения:**

В дампе присутствует команда CREATE EXTENSION pg_trgm и комментарий к расширению, то есть pg_dump сохраняет метаданные расширения как логическую операцию установки, а не разворачивает внутренние объекты поштучно.​

Для пользовательской таблицы units_of_measure выгружены структура (CREATE TABLE и PRIMARY KEY), данные (секция COPY с тремя строками справочника) и права доступа (GRANT SELECT TO ext_reader), что показывает сохранение как схемы, так и содержимого и ACL этой таблицы при логическом резервном копировании.​

### Модуль 3: Локализация

#### Задача 1: Миграция между кодировками

**Цель:** Перенести таблицу с кириллическими данными из базы в кодировке KOI8R в базу UTF8 с помощью pg_dump/psql и проверить, что текст корректно сохраняется.

**Выполненные действия:**

```sql
-- 1. Создание БД с кодировкой KOI8R
CREATE DATABASE koi8_db
  TEMPLATE template0
  ENCODING 'KOI8R'
  LOCALE 'ru_RU.KOI8-R';

\l koi8_db

-- 2. Создание таблицы и вставка строк с кириллицей в koi8_db
\c koi8_db

CREATE TABLE msg_koi8 (
    id   serial PRIMARY KEY,
    txt  text
);

INSERT INTO msg_koi8 (txt) VALUES
    ('Привет'),
    ('Тест кириллицы'),
    ('Ёлка и юг');

SELECT * FROM msg_koi8;
```

```bash
# 3. Логический дамп базы koi8_db
pg_dump -U postgres -d koi8_db > koi8_db_dump.sql
```

```sql
-- 4. Создание БД с кодировкой UTF8
\c postgres

CREATE DATABASE utf8_db
  TEMPLATE template0
  ENCODING 'UTF8'
  LOCALE 'ru_RU.UTF-8';

\l utf8_db
```

```bash
-- 5. Восстановление дампа в UTF8-базу
psql -U postgres -d utf8_db -f koi8_db_dump.sql
```

```sql
-- 6. Проверка целостности данных в utf8_db
\c utf8_db

SELECT * FROM msg_koi8 ORDER BY id;
```

**Результаты:**

```bash
                                                     List of databases
  Name   |  Owner   | Encoding | Locale Provider |   Collate    |    Ctype     | ICU Locale | ICU Rules | Access privileges 
---------+----------+----------+-----------------+--------------+--------------+------------+-----------+-------------------
 koi8_db | postgres | KOI8R    | libc            | ru_RU.KOI8-R | ru_RU.KOI8-R |            |           | 
(1 row)

 id |      txt       
----+----------------
  1 | Привет
  2 | Тест кириллицы
  3 | Ёлка и юг
(3 rows)

                                                    List of databases
  Name   |  Owner   | Encoding | Locale Provider |   Collate   |    Ctype    | ICU Locale | ICU Rules | Access privileges 
---------+----------+----------+-----------------+-------------+-------------+------------+-----------+-------------------
 utf8_db | postgres | UTF8     | libc            | ru_RU.UTF-8 | ru_RU.UTF-8 |            |           | 
(1 row)

 id |      txt       
----+----------------
  1 | Привет
  2 | Тест кириллицы
  3 | Ёлка и юг
(3 rows)
```

**Выводы и объяснения:**

База koi8_db была успешно создана с кодировкой KOI8R и локалью ru_RU.KOI8-R, в ней таблица msg_koi8 корректно хранит строки с кириллицей.​

Логический дамп pg_dump и дальнейшее восстановление в базу utf8_db в кодировке UTF8 привели к тому, что PostgreSQL перекодировал текстовые данные из KOI8R в UTF8, и при проверке содержимое msg_koi8 полностью совпадает с исходным; аналогичная миграция может дать проблемы только при "битых" данных или неверно заданных кодировках, тогда для решения используют корректную настройку client_encoding/ENCODING, внешнюю перекодировку дампа (iconv) или предварительную очистку данных.

#### Задача 2: Локализация дат

**Цель:** Проверить, влияет ли изменение параметров локализации (lc_time) на числовой номер дня недели, возвращаемый функцией EXTRACT(DOW FROM CURRENT_DATE).

**Выполненные действия:**

```sql
-- 1. Получаем номер сегодняшнего дня недели
SELECT CURRENT_DATE,
       EXTRACT(DOW FROM CURRENT_DATE) AS dow_before;

-- 2. Смотрим текущий lc_time в сеансе
SHOW lc_time;

-- 3. Меняем локаль для форматирования дат/времени в рамках сеанса
SET lc_time = 'ru_RU.UTF-8';

-- 4. Повторно получаем номер дня недели
SELECT CURRENT_DATE,
       EXTRACT(DOW FROM CURRENT_DATE) AS dow_after;

-- 5. Для наглядности форматируем дату с названием дня недели
SELECT to_char(CURRENT_DATE, 'Day, DD Mon YYYY') AS formatted_date;
```

**Результаты:**

```bash
 current_date | dow_before 
--------------+------------
 2025-11-30   |          6
(1 row)

   lc_time   
-------------
 ru_RU.UTF-8
(1 row)

 current_date | dow_after 
--------------+-----------
 2025-11-30   |         6
(1 row)

     formatted_date     
------------------------
 Sunday , 30 Nov 2025
(1 row)
```

**Выводы и объяснения:**

Значение EXTRACT(DOW FROM CURRENT_DATE) до и после смены lc_time остаётся одинаковым (6), потому что DOW - это чисто числовая часть даты, завязанная на календарь, а не на языковые настройки.​

Параметр lc_time влияет только на текстовое форматирование дат и времени (например, язык и форму вывода Day/Mon в to_char); в текущей конфигурации названия дня и месяца выводятся по‑английски, хотя lc_time установлен в ru_RU.UTF-8, что связано с доступными локалями и способом их поддержки в сборке PostgreSQL.

## Результаты выполнения

### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1. Базовые привилегии | ✅Выполнено | Создана база access_db, роли writer и reader, пользователи w1 и r1; у public отозваны все права на схему public, роли writer выданы USAGE, CREATE, роли reader - USAGE; через ALTER DEFAULT PRIVILEGES настроено автоматическое GRANT SELECT для reader на новые таблицы writer, проверено, что w1 имеет полный доступ к test_table, а r1 может только читать. |
| 1 | 2. Аутентификация (Практика+) | ❌Не выполнено |  |
| 2 | 1. Установка расширения | ✅Выполнено | В базе lab07 установлено расширение pg_trgm, в pg_available_extensions и pg_extension зафиксировано наличие версии 1.6, что подтверждает корректную установку расширения. |
| 2 | 2. Создание и исследование | ✅Выполнено | Расширение pg_trgm создано без указания версии; в pg_extension определена установленная версия 1.6, а в pg_available_extension_versions видно, что доступны версии 1.3–1.6, причём 1.6 помечена как installed = true. |
| 2 | 3. Добавление данных | ✅Выполнено | Для демонстрации "справочника расширения" создана таблица units_of_measure с базовой единицей m и добавлены единицы ft и in с коэффициентами перевода к метрам (0.3048 и 0.0254), что позволяет использовать справочник для конвертации значений. |
| 2 | 4. Управление доступом | ✅Выполнено | Для units_of_measure отозвано право SELECT у PUBLIC, создана роль ext_reader, ей выдан SELECT на таблицу и добавлен пользователь r1; проверено, что r1 может читать справочник, а w1 получает permission denied, что демонстрирует управление доступом через специальную роль. |
| 2 | 5. Резервное копирование | ✅Выполнено | С помощью pg_dump получен дамп базы lab07: в нём присутствуют команды CREATE EXTENSION pg_trgm, COMMENT ON EXTENSION, создание таблицы units_of_measure, секция COPY с данными и GRANT SELECT TO ext_reader, что подтверждает выгрузку метаданных и данных. |
| 3 | 1. Миграция между кодировками | ✅Выполнено | Создана база koi8_db с кодировкой KOI8R и локалью ru_RU.KOI8-R, в ней таблица msg_koi8 с кириллическими строками; после pg_dump и восстановления дампа в базу utf8_db (UTF8, ru_RU.UTF-8) проверено, что строки в msg_koi8 в UTF8‑базе полностью совпадают с исходными. |
| 3 | 2. Локализация дат | ✅Выполнено | Для текущей даты получен EXTRACT(DOW) = 6 до и после SET lc_time = 'ru_RU.UTF-8'; при этом значение DOW не изменилось, а to_char(CURRENT_DATE, 'Day, DD Mon YYYY') вернуло формат с английскими названиями (Sunday , 30 Nov 2025), что демонстрирует независимость EXTRACT от локали и использование lc_time только при форматировании. |

## Анализ и выводы

### Основные наблюдения

1. Механизм ролей и привилегий в PostgreSQL позволяет чётко разделять права на создание объектов и доступ к данным: роль writer получает возможность создавать и изменять объекты в схеме public, роль reader - только использовать схему и читать данные, а ALTER DEFAULT PRIVILEGES обеспечивает автоматическую выдачу SELECT на будущие таблицы без дополнительного администрирования.

2. Расширения устанавливаются как логические модули через CREATE EXTENSION и отражаются в системных представлениях: версия берётся из default_version, а подробности по доступным версиям и установочному статусу видны в pg_available_extension_versions; пользовательские объекты, связанные с расширением (например, справочник единиц), резервируются и восстанавливаются как обычные таблицы через pg_dump/psql.

3. Контроль доступа к объектам расширений и пользовательским таблицам следует тем же правилам, что и для обычных объектов: отзыв прав у PUBLIC, выдача их специализированным ролям и включение пользователей в эти роли позволяют ограничить круг читающих, не меняя структуру данных; это особенно важно для справочников и служебных таблиц.

4. При миграции между кодировками (KOI8R → UTF8) логический дамп обеспечивает корректную перекодировку текстовых данных при условии, что исходная кодировка базы и локали заданы корректно, а данные не содержат "битых" байтов; при ошибках (invalid byte sequence) требуется предварительная чистка данных или внешняя перекодировка дампа.

5. Параметр lc_time влияет только на текстовое представление дат и времени в функциях форматирования (to_char и др.), тогда как функции извлечения числовых частей дат, такие как EXTRACT(DOW FROM CURRENT_DATE), работают независимо от локали и возвращают значения, завязанные исключительно на календарь.

### Сравнительный анализ

#### Управление доступом и аутентификация

- В задании 1.1 права доступа были реализованы полностью на уровне SQL (GRANT/REVOKE, ALTER DEFAULT PRIVILEGES), без изменения способов аутентификации: пользователи w1 и r1 входили по паролю и наследовали права групповых ролей writer и reader.

- Задание 1.2 по настройке pg_hba.conf и аутентификации trust/md5/peer не выполнялось в рамках работы, поэтому управление доступом к БД реализовано только авторизацией (привилегиями после входа), а не на уровне допуска к соединению; практическая часть с OS‑пользователями и peer‑аутентификацией осталась на теоретическом уровне.

#### Расширения, данные и резервное копирование

- В отличие от пользовательских объектов, внутренние объекты расширения (функции, типы, операторы) не разворачиваются в дампе поштучно: pg_dump записывает CREATE EXTENSION и комментарии, предполагая, что необходимые файлы расширения будут установлены на целевой системе; сами справочные таблицы, созданные пользователем (например, units_of_measure), выгружаются полностью, включая структуру, данные и ACL.

- Настройка доступа к данным расширения (отзыв SELECT у PUBLIC, выдача специализированной роли) сохраняется в дампе через команды GRANT/REVOKE, что позволяет при восстановлении воссоздать не только схему и содержимое, но и модель прав; это важно при переносе систем между контурами (dev/test/prod).

#### Локализация и работа с датами

- При миграции между KOI8R и UTF8 PostgreSQL, опираясь на системные локали (LC_COLLATE, LC_CTYPE) и поддержку кодировок, автоматически перекодирует строки при выполнении SQL‑скрипта дампа, поэтому при корректных исходных данных кириллический текст сохраняется без искажений; проблемы появляются в основном при базах SQL_ASCII и смешанных/некорректных данных.

- Числовые функции над датами (EXTRACT, DATE_PART) ведут себя одинаково в любых локалях, тогда как lc_time используется только в форматирующих функциях (to_char) и зависит от того, какие локали реально доступны в ОС и как настроен провайдер локалей (libc или icu) в кластере; поэтому смена lc_time не меняет номер дня недели, но может менять язык и формат вывода даты.
