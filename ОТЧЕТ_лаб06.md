# Отчет по лабораторной работе №6  
# Блокировки и мониторинг в PostgreSQL

## Сведения о студенте

**Дата:** 21.11.2025  
**Семестр:** 7 семестр  
**Группа:** ПИЖ-Б-О-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Имран Борисович

## Цель работы

Изучение системы блокировок в PostgreSQL 16, включая блокировки объектов, строк и буферов в памяти, а также механизмов обнаружения взаимоблокировок.

Получение практических навыков использования представлений pg_locks, pg_stat_activity, семейства представлений pg_stat_* и расширений pg_stat_statements и pg_buffercache для мониторинга активности и диагностики блокировок.

## Теоретическая часть

### Изученные концепции

- **Блокировки:** Механизм синхронизации параллельного доступа к данным, включающий блокировки на уровне объектов (таблицы, индексы), строк и внутренних структур, таких как буферы в shared_buffers.

- **Мониторинг (pg_stat_*):** Система накопительной статистики и динамических представлений (pg_stat_activity, pg_stat_all_tables, pg_stat_all_indexes и др.) для отслеживания активности сессий, нагрузок на таблицы и индексы, а также ожиданий блокировок.

- **pg_locks:** Представление, показывающее все активные и ожидающие блокировки в кластере, с указанием типа блокировки, объекта и PID процесса, которое обычно связывают с pg_stat_activity для анализа запросов, держащих или ожидающих блокировки.

- **pg_stat_statements:** Расширение, собирающее агрегированную статистику по выполнявшимся запросам (количество вызовов, время, чтения/записи), полезное для выявления "тяжёлых" запросов, часто вызывающих блокировки.

- **pg_buffercache:** Расширение, позволяющее посмотреть содержимое буферного кеша и увидеть, какие страницы таблиц и индексов сейчас находятся в памяти, что помогает связывать блокировки и загрузку буферов.

### Ключевые термины

- **Lock (блокировка):** Состояние, при котором транзакция удерживает ресурс (объект или строку) в определённом режиме (например, RowExclusiveLock или AccessExclusiveLock), ограничивая параллельные операции других транзакций.

- **Блокировка строк (row-level lock):** Тонкая блокировка отдельных версий строк (SELECT FOR UPDATE, UPDATE, DELETE), позволяющая другим транзакциям продолжать работу с другими строками той же таблицы.

- **Лёгкие блокировки (lightweight locks, LWLocks):** Внутренний механизм синхронизации доступа к структурам памяти (bufmgr, shared catalogs и т.п.), который фиксируется в wait_event_type/wait_event в pg_stat_activity при ожидании.

- **Мониторинг активности (pg_stat_activity):** Представление "одна строка на процесс", показывающее текущее состояние сессии, выполняемый запрос, время выполнения и события ожидания, включая ожидание блокировок.

- **Deadlock (взаимоблокировка):** Ситуация, когда две или более транзакции циклически ждут ресурсы друг друга, из которой невозможно выйти без принудительного прерывания хотя бы одной транзакции.

- **Обнаружение взаимоблокировок:** Периодический алгоритм PostgreSQL, который строит граф ожиданий (wait-for graph) по блокирующим и ожидающим транзакциям и при обнаружении цикла прерывает одну из транзакций с ошибкой "deadlock detected".

- **log_lock_waits и deadlock_timeout:** Параметры конфигурации, позволяющие логировать долгие ожидания блокировок и инициировать проверку взаимоблокировок после заданного времени ожидания, что упрощает диагностику проблем с конкурентным доступом.

## Практическая часть

### Модуль 1: Мониторинг активности

#### Задача 1: Статистика таблиц

**Цель:** Исследовать, как операции INSERT и DELETE отражаются в статистике pg_stat_all_tables (n_tup_ins, n_tup_del, n_live_tup, n_dead_tup) и как изменяются показатели после выполнения VACUUM.

**Выполненные действия:**

```sql
-- 1. Создание тестовой таблицы
CREATE TABLE monitor_test (
    id INT
);

-- 2. Вставка нескольких строк
INSERT INTO monitor_test (id)
VALUES (1), (2), (3), (4), (5);

-- 3. Удаление всех строк
DELETE FROM monitor_test;

-- 4. Просмотр статистики до VACUUM
SELECT
    relname,
    n_tup_ins,
    n_tup_del,
    n_live_tup,
    n_dead_tup
FROM
    pg_stat_all_tables
WHERE
    relname = 'monitor_test';

-- 5. Очистка таблицы
VACUUM monitor_test;

-- 6. Просмотр статистики после VACUUM
SELECT
    relname,
    n_tup_ins,
    n_tup_del,
    n_live_tup,
    n_dead_tup
FROM
    pg_stat_all_tables
WHERE
    relname = 'monitor_test';
```

**Результаты:**

```bash
   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
--------------+-----------+-----------+------------+------------
 monitor_test |         5 |         5 |          0 |          5
(1 row)

   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
--------------+-----------+-----------+------------+------------
 monitor_test |         5 |         5 |          0 |          0
(1 row)
```

**Выводы и объяснения:**

Показатель n_tup_ins стал равен 5, потому что в таблицу один раз было вставлено 5 строк, и счётчик фиксирует суммарное количество вставок с момента инициализации статистики.​

Показатель n_tup_del тоже равен 5, так как команда DELETE удалила все 5 строк, поэтому живых строк в таблице не осталось (n_live_tup = 0), а до VACUUM все они учитывались как мёртвые кортежи (n_dead_tup = 5).​

После выполнения VACUUM сервер физически переработал мёртвые кортежи и освободил их место для повторного использования, поэтому n_dead_tup для monitor_test стал 0, при этом накопительные счётчики n_tup_ins и n_tup_del не обнулились и остались равны 5.

#### Задача 2: Взаимоблокировка

**Цель:** Создать простую ситуацию взаимоблокировки двух транзакций и посмотреть, какие сообщения записывает сервер PostgreSQL в журнал при обнаружении deadlock.

**Выполненные действия:**

```sql
-- Подготовка таблицы (можно было сделать заранее в одной сессии)
CREATE TABLE deadlock_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO deadlock_test (id, data) VALUES
    (1, 'row1'),
    (2, 'row2');
```

```sql
-- Сессия 1
BEGIN;
-- Блокируем строку с id = 1
UPDATE deadlock_test
SET data = 'row1-tx1'
WHERE id = 1;
```

```sql
-- Сессия 2
BEGIN;
-- Блокируем строку с id = 2
UPDATE deadlock_test
SET data = 'row2-tx2'
WHERE id = 2;
```

```sql
-- Сессия 1
-- Пытаемся обновить строку с id = 2
UPDATE deadlock_test
SET data = 'row2-tx1'
WHERE id = 2;
```

```sql
-- Сессия 2
-- Пытаемся обновить строку с id = 1 (взаимное ожидание с сессией 1)
UPDATE deadlock_test
SET data = 'row1-tx2'
WHERE id = 1;
```

```sql
-- После возникновения взаимоблокировки откатываем транзакцию
ROLLBACK;
```

```bash
# Просмотр журнала сообщений сервера (во внешнем shell)
tail -n 50 logfile
```

**Результаты:**

```bash
# Сессия 2 (Попытка обновить строку с id = 1)
ERROR:  deadlock detected
DETAIL:  Process 269469 waits for ShareLock on transaction 629029; blocked by process 269460.
Process 269460 waits for ShareLock on transaction 629030; blocked by process 269469.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "deadlock_test"

# logfile
2025-11-21 13:53:17.138 MSK [269469] ERROR:  deadlock detected
2025-11-21 13:53:17.138 MSK [269469] DETAIL:  Process 269469 waits for ShareLock on transaction 629029; blocked by process 269460.
        Process 269460 waits for ShareLock on transaction 629030; blocked by process 269469.
        Process 269469: UPDATE deadlock_test
        SET data = 'row1-tx2'
        WHERE id = 1;
        Process 269460: UPDATE deadlock_test
        SET data = 'row2-tx1'
        WHERE id = 2;
2025-11-21 13:53:17.138 MSK [269469] HINT:  See server log for query details.
2025-11-21 13:53:17.138 MSK [269469] CONTEXT:  while updating tuple (0,1) in relation "deadlock_test"
2025-11-21 13:53:17.138 MSK [269469] STATEMENT:  UPDATE deadlock_test
        SET data = 'row1-tx2'
        WHERE id = 1;
```

**Выводы и объяснения:**

Взаимоблокировка возникла, потому что одна транзакция удерживала блокировку на строке с id = 1 и пыталась обновить строку с id = 2, а вторая транзакция удерживала блокировку на строке с id = 2 и пыталась обновить строку с id = 1, то есть образовался цикл взаимных ожиданий между двумя процессами.​

PostgreSQL обнаружил цикл ожиданий в графе блокировок, прервал одну из транзакций с ошибкой "deadlock detected" и записал в журнал подробности: какие процессы ждут каких транзакций, какие именно запросы выполнялись и в каком контексте (обновление какого кортежа таблицы deadlock_test), что позволяет диагностировать и воспроизвести источник взаимоблокировки.​

### Модуль 2: Блокировки объектов

#### Задача 1: Блокировки при чтении

**Цель:** Показать, какие блокировки захватываются при чтении строки по первичному ключу на уровне изоляции Read Committed и как это отражается в pg_locks.

**Выполненные действия:**

```sql
-- 0. Проверка уровня изоляции
SHOW default_transaction_isolation;

-- 1. Подготовка таблицы
DROP TABLE IF EXISTS lock_read_test;
CREATE TABLE lock_read_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO lock_read_test (id, data) VALUES
    (1, 'row1'),
    (2, 'row2');

-- 2. Чтение одной строки в рамках транзакции
BEGIN;

SELECT *
FROM lock_read_test
WHERE id = 1;

-- 3. Просмотр блокировок по таблице
SELECT
    locktype,
    relation::regclass AS relname,
    mode,
    granted
FROM pg_locks
WHERE relation = 'lock_read_test'::regclass;

-- 4. Завершение транзакции
COMMIT;
```

**Результаты:**

```bash
 default_transaction_isolation 
-------------------------------
 read committed
(1 row)

 id | data 
----+------
  1 | row1
(1 row)

 locktype |    relname     |      mode       | granted 
----------+----------------+-----------------+---------
 relation | lock_read_test | AccessShareLock | t
(1 row)
```

**Выводы и объяснения:**

Уровень изоляции по умолчанию действительно Read Committed, поэтому каждое выражение SELECT видит зафиксованные на момент начала оператора изменения и не удерживает снимок на всю транзакцию.​

При выполнении SELECT по первичному ключу таблица lock_read_test получила блокировку типа AccessShareLock на уровне relation, которая позволяет параллельные чтения и не мешает другим читателям или большинству операций записи; при этом строковые блокировки не ставятся, так как обычный SELECT без FOR UPDATE использует MVCC и читает нужную версию кортежа без захвата row-level locks.

#### Задача 2: Повышение уровня блокировок

**Цель:** Показать автоматическое повышение уровня предикатных блокировок при чтении по индексу на уровне SERIALIZABLE и возникающую из‑за этого ошибку сериализации (could not serialize access...).

**Выполненные действия:**

```sql
-- Подготовка (один раз, до эксперимента)
DROP TABLE IF EXISTS pred_lock_test;
CREATE TABLE pred_lock_test (
    id   INT PRIMARY KEY,
    grp  INT,
    data TEXT
);

CREATE INDEX pred_lock_test_grp_idx ON pred_lock_test (grp);

INSERT INTO pred_lock_test (id, grp, data) VALUES
    (1, 1, 'row1'),
    (2, 2, 'row2');

SET enable_seqscan = off;
```

```sql
-- Сессия 1
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 1. Читаем группу 1 по индексу
SELECT * FROM pred_lock_test WHERE grp = 1;
```

```sql
-- Сессия 2
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- 2. Читаем группу 2 по индексу
SELECT * FROM pred_lock_test WHERE grp = 2;
```

```sql
-- Сессия 1
-- 3. Пишем в "чужую" группу 2
INSERT INTO pred_lock_test (id, grp, data)
VALUES (3, 2, 'row3-tx1');
```

```sql
-- Сессия 2
-- 4. Пишем в "чужую" группу 1
INSERT INTO pred_lock_test (id, grp, data)
VALUES (4, 1, 'row4-tx2');
```

```sql
-- Сессия 1
-- 5. Первая пытается зафиксироваться
COMMIT;
```

```sql
-- Сессия 2
-- 6. Вторая пытается зафиксироваться
COMMIT;
```

**Результаты:**

```bash
 id | grp | data 
----+-----+------
  1 |   1 | row1
(1 row)

 id | grp | data 
----+-----+------
  2 |   2 | row2
(1 row)

# Попытка коммита во второй сессии
ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```

**Выводы и объяснения:**

Обе транзакции работали на уровне изоляции SERIALIZABLE, каждая читала один диапазон по индексу (grp = 1 и grp = 2), а потом записывала данные в "чужой" диапазон, что создало цепочку read/write‑зависимостей между ними.​

Механизм SSI в PostgreSQL отслеживает такие зависимости с помощью предикатных блокировок: диапазоны, прочитанные по индексу, помечаются SIREAD‑блокировками, которые при конфликте могут "подняться" до более грубого уровня и образовать опасный цикл; в результате при COMMIT второй транзакции сервер обнаружил потенциальное нарушение сериализуемости и прервал её с ошибкой could not serialize access, хотя логическое состояние данных можно было бы упорядочить как последовательное исполнение - это и есть пример "ложной" ошибки сериализации, которую стандарт предписывает решать повторным запуском транзакции.​

#### Задача 3: Логирование долгих ожиданий

**Цель:** Настроить логирование ожиданий блокировок дольше 100 мс с помощью параметров log_lock_waits и deadlock_timeout и убедиться по журналу, что длительное ожидание действительно зафиксировано.​

**Выполненные действия:**

```sql
-- 1. Настройка параметров логирования (от суперпользователя)
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = '100ms';

SELECT pg_reload_conf();

-- 2. Подготовка таблицы
DROP TABLE IF EXISTS lock_wait_test;
CREATE TABLE lock_wait_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO lock_wait_test (id, data) VALUES (1, 'row1');
```

```sql
-- Сессия 1
BEGIN;
UPDATE lock_wait_test
SET data = 'row1-locked'
WHERE id = 1;
```

```sql
-- Сессия 2
BEGIN;
UPDATE lock_wait_test
SET data = 'row1-wait'
WHERE id = 1;
```

```sql
-- Сессия 1
-- ждем некоторое время
COMMIT;
```

```sql
-- Сессия 2
COMMIT;
```

```bash
tail -n 50 logfile 
```

**Результаты:**

```bash
...
2025-11-21 17:46:03.990 MSK [280344] LOG:  starting PostgreSQL 16.0 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, 64-bit
2025-11-21 17:46:03.990 MSK [280344] LOG:  listening on IPv4 address "127.0.0.1", port 5555
2025-11-21 17:46:04.001 MSK [280344] LOG:  listening on Unix socket "/tmp/.s.PGSQL.5555"
2025-11-21 17:46:04.011 MSK [280347] LOG:  database system was shut down at 2025-11-21 17:46:03 MSK
2025-11-21 17:46:04.020 MSK [280344] LOG:  database system is ready to accept connections
2025-11-21 17:46:33.466 MSK [280344] LOG:  received SIGHUP, reloading configuration files
2025-11-21 17:46:38.377 MSK [280462] LOG:  automatic analyze of table "lab06.pg_catalog.pg_class"
	avg read rate: 17.463 MB/s, avg write rate: 4.596 MB/s
	buffer usage: 1205 hits, 38 misses, 10 dirtied
	system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.01 s
2025-11-21 17:47:04.487 MSK [280497] LOG:  process 280497 still waiting for ShareLock on transaction 629071 after 101.177 ms
2025-11-21 17:47:04.487 MSK [280497] DETAIL:  Process holding the lock: 280505. Wait queue: 280497.
2025-11-21 17:47:04.487 MSK [280497] CONTEXT:  while updating tuple (0,1) in relation "lock_wait_test"
2025-11-21 17:47:04.487 MSK [280497] STATEMENT:  UPDATE lock_wait_test
	SET data = 'row1-wait'
	WHERE id = 1;
2025-11-21 17:47:39.945 MSK [280497] LOG:  process 280497 acquired ShareLock on transaction 629071 after 35559.424 ms
2025-11-21 17:47:39.945 MSK [280497] CONTEXT:  while updating tuple (0,1) in relation "lock_wait_test"
2025-11-21 17:47:39.945 MSK [280497] STATEMENT:  UPDATE lock_wait_test
	SET data = 'row1-wait'
	WHERE id = 1;
```

**Выводы и объяснения:**

Сообщение process 280497 still waiting for ShareLock on transaction 629071 after 101.177 ms показывает, что параметр log_lock_waits = on совместно с deadlock_timeout = 100ms включил запись в лог о том, что процесс ждал блокировку дольше порога: лог содержит тип блокировки, удерживающий процесс и SQL‑оператор, который ждёт.​

Позднее сообщение process 280497 acquired ShareLock ... after 35559.424 ms фиксирует момент получения блокировки после долгого ожидания, подтверждая, что длительный конфликт из‑за блокировки на строке lock_wait_test был успешно диагностирован средствами логирования, без взаимоблокировки.

### Модуль 3: Блокировки строк

#### Задача 1: Конфликт обновлений

**Цель:** Смоделировать конфликт обновлений одной и той же строки в трёх разных сеансах, посмотреть строковые и транзакционные блокировки в pg_locks и объяснить их тип и назначение.

**Выполненные действия:**

```sql
-- Подготовка (одна сессия, один раз)
DROP TABLE IF EXISTS row_lock_test;
CREATE TABLE row_lock_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO row_lock_test (id, data) VALUES (1, 'row1');
```

```sql
-- Сессия 1
BEGIN;
UPDATE row_lock_test
SET data = 'row1-tx1'
WHERE id = 1;
```

```sql
-- Сессия 2
BEGIN;
UPDATE row_lock_test
SET data = 'row1-tx2'
WHERE id = 1;
```

```sql
-- Сессия 3
BEGIN;
UPDATE row_lock_test
SET data = 'row1-tx3'
WHERE id = 1;
```

```sql
-- Сессия 1
-- Посмотреть свои блокировки
SELECT
    locktype,
    relation::regclass AS rel,
    mode,
    granted
FROM pg_locks
WHERE pid = pg_backend_pid()
ORDER BY locktype, mode;
```

```sql
-- Сессия 4
-- Посмотреть свои блокировки
SELECT 
    pid, 
    locktype, 
    relation::regclass, 
    mode, 
    granted 
FROM pg_locks 
WHERE relation = 'row_lock_test'::regclass 
ORDER BY pid, locktype, mode;
```

```sql
-- Сессия 1
COMMIT;
```

```sql
-- Сессия 2
COMMIT;
```

```sql
-- Сессия 3
COMMIT;
```

**Результаты:**

```bash
# Вывод сессии 1
   locktype    |        rel         |       mode       | granted 
---------------+--------------------+------------------+---------
 relation      | pg_locks           | AccessShareLock  | t
 relation      | row_lock_test_pkey | RowExclusiveLock | t
 relation      | row_lock_test      | RowExclusiveLock | t
 transactionid |                    | ExclusiveLock    | t
 virtualxid    |                    | ExclusiveLock    | t
(5 rows)

# Вывод сессии 4
  pid   | locktype |   relation    |       mode       | granted 
--------+----------+---------------+------------------+---------
 280497 | relation | row_lock_test | RowExclusiveLock | t
 280497 | tuple    | row_lock_test | ExclusiveLock    | t
 280505 | relation | row_lock_test | RowExclusiveLock | t
 281729 | relation | row_lock_test | RowExclusiveLock | t
 281729 | tuple    | row_lock_test | ExclusiveLock    | f
(5 rows)
```

**Выводы и объяснения:**

Первая сессия при выполнении UPDATE берёт на таблицу row_lock_test и её индекс RowExclusiveLock (блокировка уровня relation), а также строковую блокировку типа ExclusiveLock на кортеж, поэтому в pg_locks видно и блокировку уровня relation, и tuple‑блокировку с granted = t; дополнительные ExclusiveLock на transactionid и virtualxid относятся к самой транзакции и её идентификатору.​

Вторая и третья сессии также получают RowExclusiveLock на таблицу (это не конфликтует между собой), но их строковые блокировки на тот же кортеж отображаются как tuple ExclusiveLock с granted = f: они стоят в очереди, пока первая транзакция не завершится; после COMMIT в сессии 1 строковая блокировка передаётся следующей транзакции, затем следующей, что демонстрирует, как PostgreSQL сериализует обновления одной строки с помощью row-level locks и очереди ожидания.

#### Задача 2: Взаимоблокировка трех транзакций

**Цель:** Воспроизвести взаимоблокировку трёх транзакций и по журналу сообщений PostgreSQL понять, какие процессы и какие запросы образовали цикл ожиданий.

**Выполненные действия:**

```sql
-- Подготовка (одна сессия, один раз)
DROP TABLE IF EXISTS deadlock3_test;
CREATE TABLE deadlock3_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO deadlock3_test (id, data) VALUES
    (1, 'row1'),
    (2, 'row2'),
    (3, 'row3');
```

```sql
-- Сессия 1
BEGIN;
UPDATE deadlock3_test SET data = 'row1-tx1' WHERE id = 1;
```

```sql
-- Сессия 2
BEGIN;
UPDATE deadlock3_test SET data = 'row2-tx2' WHERE id = 2;
```

```sql
-- Сессия 3
BEGIN;
UPDATE deadlock3_test SET data = 'row3-tx3' WHERE id = 3;
```

```sql
-- СЕССИЯ 1: ждёт строку, которую держит СЕССИЯ 2
UPDATE deadlock3_test SET data = 'row2-from-tx1' WHERE id = 2;
```

```sql
-- СЕССИЯ 2: ждёт строку, которую держит СЕССИЯ 3
UPDATE deadlock3_test SET data = 'row3-from-tx2' WHERE id = 3;
```

```sql
-- СЕССИЯ 3: ждёт строку, которую держит СЕССИЯ 1
UPDATE deadlock3_test SET data = 'row1-from-tx3' WHERE id = 1;
```

```sql
-- Во всех сессиях
ROLLBACK;
```

```bash
sudo tail -n 50 logfile
```

**Результаты:**

```bash
# Сессия 3
ERROR:  deadlock detected
DETAIL:  Process 284316 waits for ShareLock on transaction 629087; blocked by process 284295.
Process 284295 waits for ShareLock on transaction 629088; blocked by process 284306.
Process 284306 waits for ShareLock on transaction 629089; blocked by process 284316.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "deadlock3_test"

# logfile
2025-11-21 18:10:07.348 MSK [284295] LOG:  process 284295 still waiting for ShareLock on transaction 629088 after 100.917 ms
2025-11-21 18:10:07.348 MSK [284295] DETAIL:  Process holding the lock: 284306. Wait queue: 284295.
2025-11-21 18:10:07.348 MSK [284295] CONTEXT:  while updating tuple (0,2) in relation "deadlock3_test"
2025-11-21 18:10:07.348 MSK [284295] STATEMENT:  UPDATE deadlock3_test SET data = 'row2-from-tx1' WHERE id = 2;
2025-11-21 18:10:12.270 MSK [284306] LOG:  process 284306 still waiting for ShareLock on transaction 629089 after 101.965 ms
2025-11-21 18:10:12.270 MSK [284306] DETAIL:  Process holding the lock: 284316. Wait queue: 284306.
2025-11-21 18:10:12.270 MSK [284306] CONTEXT:  while updating tuple (0,3) in relation "deadlock3_test"
2025-11-21 18:10:12.270 MSK [284306] STATEMENT:  UPDATE deadlock3_test SET data = 'row3-from-tx2' WHERE id = 3;
2025-11-21 18:10:16.551 MSK [284316] LOG:  process 284316 detected deadlock while waiting for ShareLock on transaction 629087 after 111.528 ms
2025-11-21 18:10:16.551 MSK [284316] DETAIL:  Process holding the lock: 284295. Wait queue: .
2025-11-21 18:10:16.551 MSK [284316] CONTEXT:  while updating tuple (0,1) in relation "deadlock3_test"
2025-11-21 18:10:16.551 MSK [284316] STATEMENT:  UPDATE deadlock3_test SET data = 'row1-from-tx3' WHERE id = 1;
2025-11-21 18:10:16.552 MSK [284316] ERROR:  deadlock detected
2025-11-21 18:10:16.552 MSK [284316] DETAIL:  Process 284316 waits for ShareLock on transaction 629087; blocked by process 284295.
	Process 284295 waits for ShareLock on transaction 629088; blocked by process 284306.
	Process 284306 waits for ShareLock on transaction 629089; blocked by process 284316.
	Process 284316: UPDATE deadlock3_test SET data = 'row1-from-tx3' WHERE id = 1;
	Process 284295: UPDATE deadlock3_test SET data = 'row2-from-tx1' WHERE id = 2;
	Process 284306: UPDATE deadlock3_test SET data = 'row3-from-tx2' WHERE id = 3;
2025-11-21 18:10:16.552 MSK [284316] HINT:  See server log for query details.
2025-11-21 18:10:16.552 MSK [284316] CONTEXT:  while updating tuple (0,1) in relation "deadlock3_test"
2025-11-21 18:10:16.552 MSK [284316] STATEMENT:  UPDATE deadlock3_test SET data = 'row1-from-tx3' WHERE id = 1;
2025-11-21 18:10:16.552 MSK [284306] LOG:  process 284306 acquired ShareLock on transaction 629089 after 4384.456 ms
2025-11-21 18:10:16.552 MSK [284306] CONTEXT:  while updating tuple (0,3) in relation "deadlock3_test"
2025-11-21 18:10:16.552 MSK [284306] STATEMENT:  UPDATE deadlock3_test SET data = 'row3-from-tx2' WHERE id = 3;
2025-11-21 18:10:23.209 MSK [284295] LOG:  process 284295 acquired ShareLock on transaction 629088 after 15961.324 ms
2025-11-21 18:10:23.209 MSK [284295] CONTEXT:  while updating tuple (0,2) in relation "deadlock3_test"
2025-11-21 18:10:23.209 MSK [284295] STATEMENT:  UPDATE deadlock3_test SET data = 'row2-from-tx1' WHERE id = 2;
2025-11-21 18:13:17.769 MSK [284265] LOG:  checkpoint starting: time
2025-11-21 18:13:21.167 MSK [284265] LOG:  checkpoint complete: wrote 35 buffers (0.2%); 0 WAL file(s) added, 0 removed, 0 recycled; write=3.335 s, sync=0.036 s, total=3.399 s; sync files=28, longest=0.008 s, average=0.002 s; distance=76 kB, estimate=76 kB; lsn=0/3D1B0038, redo lsn=0/3D1AFFE8
```

**Выводы и объяснения:**

Из лога видно, что три процесса (284295, 284306, 284316) образовали цикл: один ждёт ShareLock на транзакцию 629088, которая удерживается вторым процессом, второй ждёт ShareLock на транзакцию 629089 (третья транзакция), а третий ждёт ShareLock на транзакцию 629087 (первая транзакция), то есть получился замкнутый круг T1 > T2 > T3 > T1.​ 

Сообщение ERROR/DETAIL перечисляет не только цепочку ожиданий, но и конкретные SQL‑операторы каждой транзакции (UPDATE deadlock3_test SET data = ... WHERE id = ...), а также контекст (какой кортеж и какая таблица), поэтому по журналу можно явно увидеть, какие строки и какие запросы участвовали во взаимоблокировке и по какому циклу транзакции взаимно блокировали друг друга.​

#### Задача 3: Взаимоблокировка UPDATE

**Цель:** Понять, может ли возникнуть взаимоблокировка только между двумя транзакциями, каждая из которых выполняет один оператор UPDATE на одной и той же таблице, и в каких случаях это возможно.

**Выводы и объяснения:**

Две транзакции, каждая выполняющая один UPDATE по одной строке одной таблицы, не могут образовать взаимоблокировку: одна из них просто будет ждать освобождения блокировки строки другой, но обратного ожидания не возникает, поэтому цикла "T1 ждёт T2, T2 ждёт T1" нет.​

Для возникновения взаимоблокировки нужны как минимум две "ступени" ожидания у каждой транзакции (каждая держит одну строку и ждёт другую), поэтому в реальных сценариях deadlock для UPDATE возникает при нескольких обновлениях в разном порядке или при сочетании UPDATE с другими операциями, но не при одном простом UPDATE в каждой транзакции.​

### Модуль 4: Блокировки в оперативной памяти

#### Задача 1: Закрепление буферов курсором

**Цель:** Показать, что открытый курсор удерживает закрепление буфера (buffer pin) для страницы с текущей строкой, что видно по полю pinning_backends в pg_buffercache.

**Выполненные действия:**

```sql
-- 1. Подключить расширение pg_buffercache (в базе lab06)
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

-- 2. Подготовить таблицу и прогреть её в буферах
DROP TABLE IF EXISTS cursor_pin_test;
CREATE TABLE cursor_pin_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO cursor_pin_test (id, data)
SELECT g, repeat('x', 100)
FROM generate_series(1, 100) AS g;

-- Прочитать таблицу, чтобы страницы попали в кеш
SELECT count(*) FROM cursor_pin_test;
```

```sql
-- 3. В первой сессии открыть курсор и прочитать одну строку
BEGIN;

DECLARE c CURSOR FOR
    SELECT * FROM cursor_pin_test ORDER BY id;

FETCH 1 FROM c;
```

```sql
-- 4. Во второй сессии посмотреть pg_buffercache по этой таблице
SELECT *
FROM pg_buffercache
WHERE relfilenode = pg_relation_filenode('cursor_pin_test'::regclass)
  AND reldatabase = (SELECT oid FROM pg_database WHERE datname = current_database())
  AND relforknumber = 0
ORDER BY relblocknumber
LIMIT 5;
```

```sql
-- Сессия 1
CLOSE c;
```

```sql
-- Сессия 2
COMMIT;
```

**Результаты:**

```bash
 count 
-------
   100
(1 row)

 id |                                                 data   
 ----+------------------------------------------------------------------------------------------------------
  1 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

bufferid | relfilenode | reltablespace | reldatabase | relforknumber | relblocknumber | isdirty | usagecount | pinning_backends 
----------+-------------+---------------+-------------+---------------+----------------+---------+------------+------------------
      386 |       32992 |          1663 |       32847 |            0 |              0 | t       |          5 |                1
      392 |       32992 |          1663 |       32847 |            0 |              1 | t       |          5 |                0
(2 rows)
```

**Выводы и объяснения:**

Расширение pg_buffercache показывает для каждой страницы в shared_buffers счётчик pinning_backends - количество серверных процессов, которые "прикрепили" (pinned) этот буфер и не позволяют его вытеснить из кеша.​

Открытый курсор после FETCH удерживает пин на странице, содержащей текущую строку, чтобы следующее чтение (следующий FETCH) могло быстро получить следующую строку без риска, что страница будет вытеснена или радикально изменена; это отражается в pg_buffercache значением pinning_backends = 1 (или больше, если буфер закреплён несколькими backend’ами).

#### Задача 2: VACUUM и закрепление буферов

**Цель:** Проверить, как VACUUM ведёт себя, если на странице таблицы есть закрепление буфера (buffer pin) из‑за открытого курсора: будет ли VACUUM ждать освобождения буфера или просто пропустит такую страницу.

**Выполненные действия:**

```sql
-- 1. Подготовка (если ещё не сделано)
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

DROP TABLE IF EXISTS cursor_vacuum_test;
CREATE TABLE cursor_vacuum_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO cursor_vacuum_test (id, data)
SELECT g, repeat('x', 100)
FROM generate_series(1, 100) AS g;

-- Прогреем таблицу
SELECT count(*) FROM cursor_vacuum_test;
```

```sql
-- Сессия 1: открыть курсор и закрепить буфер
BEGIN;

DECLARE c CURSOR FOR
    SELECT * FROM cursor_vacuum_test ORDER BY id;

-- Читаем одну строку, чтобы курсор "прикрепил" страницу
FETCH 1 FROM c;
```

```sql
-- Сессия 2: выполняем VACUUM по этой таблице
VACUUM VERBOSE cursor_vacuum_test;
```

```sql
-- Сессия 1
CLOSE c;
```

```sql
-- Сессия 2
COMMIT;
```

**Результаты:**

```bash
 id |                                                 data                                                 
----+------------------------------------------------------------------------------------------------------
  1 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

INFO:  vacuuming "lab06.public.cursor_vacuum_test"
INFO:  finished vacuuming "lab06.public.cursor_vacuum_test": index scans: 0
pages: 0 removed, 2 remain, 2 scanned (100.00% of total)
tuples: 0 removed, 100 remain, 0 are dead but not yet removable
removable cutoff: 629097, which was 0 XIDs old when operation ended
new relfrozenxid: 629095, which is 1 XIDs ahead of previous value
frozen: 0 pages from table (0.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 28.375 MB/s
buffer usage: 26 hits, 0 misses, 3 dirtied
WAL usage: 4 records, 3 full page images, 742 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
INFO:  vacuuming "lab06.pg_toast.pg_toast_32999"
INFO:  finished vacuuming "lab06.pg_toast.pg_toast_32999": index scans: 0
pages: 0 removed, 0 remain, 0 scanned (100.00% of total)
tuples: 0 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 629097, which was 0 XIDs old when operation ended
new relfrozenxid: 629097, which is 3 XIDs ahead of previous value
frozen: 0 pages from table (100.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (100.00% of total) had 0 dead item identifiers removed
avg read rate: 26.483 MB/s, avg write rate: 0.000 MB/s
buffer usage: 19 hits, 1 misses, 0 dirtied
WAL usage: 1 records, 0 full page images, 188 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
```

**Выводы и объяснения:**

VACUUM VERBOSE завершился мгновенно, без сообщений о пропущенных страницах из‑за buffer pins и без ожиданий, то есть VACUUM не блокировался на открытом курсоре и не ждал явного освобождения buffer pin.​

В этой ситуации VACUUM просто прошёл по двум страницам таблицы, не находя мёртвых строк для удаления; наличие курсора, который держит страницу в буфере, не заставило VACUUM ждать: pinned‑страницы либо обрабатываются без изменения данных, либо при наличии мёртвых строк могли бы быть пропущены и обработаны последующими проходами, но сам VACUUM не зависает, а завершает работу.​

#### Задача 3: VACUUM FREEZE и ожидание

**Цель:** Показать, что при выполнении VACUUM FREEZE по таблице, на страницу которой открыт курсор, процесс VACUUM попадает в ожидание BufferPin, то есть ждёт снятия закрепления буфера.

**Выполненные действия:**

```sql
-- 1. Подготовка (если таблица уже есть, можно использовать её же)
CREATE EXTENSION IF NOT EXISTS pg_buffercache;

DROP TABLE IF EXISTS cursor_vacuum_freeze_test;
CREATE TABLE cursor_vacuum_freeze_test (
    id   INT PRIMARY KEY,
    data TEXT
);

INSERT INTO cursor_vacuum_freeze_test (id, data)
SELECT g, repeat('x', 100)
FROM generate_series(1, 100) AS g;

SELECT count(*) FROM cursor_vacuum_freeze_test;
```

```sql
-- Сессия 1: открыть курсор и держать pin
BEGIN;

DECLARE c CURSOR FOR
    SELECT * FROM cursor_vacuum_freeze_test ORDER BY id;

FETCH 1 FROM c;
-- курсор открыт, страница с первой строкой pinned
```

```sql
-- Сессия 2: запустить VACUUM FREEZE
VACUUM (FREEZE, VERBOSE) cursor_vacuum_freeze_test;
```

```sql
-- Сессия 3: посмотреть ожидание VACUUM
SELECT
    pid,
    state,
    wait_event_type,
    wait_event,
    query
FROM pg_stat_activity
WHERE query ILIKE '%VACUUM%' AND state <> 'idle';
```

**Результаты:**

```bash
# Сессия 1
 id |                                                 data   
----+------------------------------------------------------------------------------------------------------
  1 | xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(1 row)

# Сессия 2
INFO:  aggressively vacuuming "lab06.public.cursor_vacuum_freeze_test"

# Сессия 3
  pid   | state  | wait_event_type | wait_event |                        query                        
--------+--------+-----------------+------------+-----------------------------------------------------
 284306 | active | BufferPin       | BufferPin  | VACUUM (FREEZE, VERBOSE) cursor_vacuum_freeze_test;
 284316 | active |                 |            | SELECT                                             +
        |        |                 |            |     pid,                                           +
        |        |                 |            |     state,                                         +
        |        |                 |            |     wait_event_type,                               +
        |        |                 |            |     wait_event,                                    +
        |        |                 |            |     query                                          +
        |        |                 |            | FROM pg_stat_activity                              +
        |        |                 |            | WHERE query ILIKE '%VACUUM%' AND state <> 'idle';
(2 rows)

# Сессия 1
CLOSE CURSOR

# Сессия 2
INFO:  finished vacuuming "lab06.public.cursor_vacuum_freeze_test": index scans: 0
pages: 0 removed, 2 remain, 2 scanned (100.00% of total)
tuples: 0 removed, 100 remain, 0 are dead but not yet removable
removable cutoff: 629100, which was 0 XIDs old when operation ended
new relfrozenxid: 629100, which is 3 XIDs ahead of previous value
frozen: 2 pages from table (100.00% of total) had 100 tuples frozen
index scan not needed: 0 pages from table (0.00% of total) had 0 dead item identifiers removed
avg read rate: 0.000 MB/s, avg write rate: 0.001 MB/s
buffer usage: 23 hits, 0 misses, 3 dirtied
WAL usage: 7 records, 3 full page images, 1131 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 22.89 s
INFO:  aggressively vacuuming "lab06.pg_toast.pg_toast_33006"
INFO:  finished vacuuming "lab06.pg_toast.pg_toast_33006": index scans: 0
pages: 0 removed, 0 remain, 0 scanned (100.00% of total)
tuples: 0 removed, 0 remain, 0 are dead but not yet removable
removable cutoff: 629100, which was 0 XIDs old when operation ended
new relfrozenxid: 629100, which is 3 XIDs ahead of previous value
frozen: 0 pages from table (100.00% of total) had 0 tuples frozen
index scan not needed: 0 pages from table (100.00% of total) had 0 dead item identifiers removed
avg read rate: 3.895 MB/s, avg write rate: 0.000 MB/s
buffer usage: 17 hits, 1 misses, 0 dirtied
WAL usage: 1 records, 0 full page images, 188 bytes
system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
```

**Выводы и объяснения:**

В pg_stat_activity видно, что процесс VACUUM (FREEZE, VERBOSE) находится в состоянии active с wait_event_type = BufferPin и wait_event = BufferPin, то есть он явно ждёт освобождения буфера, закреплённого другим backend’ом (в данном случае - курсором из сессии 1).​

После закрытия курсора VACUUM FREEZE возобновляет работу и завершает заморозку строк, что подтверждается выводом VERBOSE (frozen: 2 pages ...). Это показывает отличие от обычного VACUUM: для заморозки (FREEZE) сервер не может просто "пропустить" pinned‑страницу и поэтому вынужден ждать снятия buffer pin, что отражается в профиле ожиданий через событие BufferPin.​

Ниже - вариант "Результатов" и "Анализа и выводов" уже под тему блокировок и мониторинга, в том же стиле, что твой пример по WAL.

## Результаты выполнения

### Сводная таблица результатов

| Модуль | Задача | Статус | Ключевые наблюдения |
|--------|--------|--------|---------------------|
| 1 | 1 | ✅Выполнено | Создана таблица monitor_test, выполнены INSERT и DELETE; в pg_stat_all_tables зафиксированы значения n_tup_ins = 5, n_tup_del = 5, n_live_tup = 0, n_dead_tup = 5, после VACUUM счётчик n_dead_tup обнулился при сохранении накопительных счётчиков вставок и удалений. |
| 1 | 2 | ✅Выполнено | Для таблицы deadlock_test воспроизведена классическая взаимоблокировка двух транзакций при обновлении строк в разном порядке; в журнале зафиксирована ошибка deadlock detected с деталями по задействованным процессам и запросам. |
| 1 | 3 | ❌Не выполнено | |
| 2 | 1 | ✅Выполнено | На уровне изоляции Read Committed обычный SELECT по первичному ключу берёт для таблицы и индекса только блокировки типа AccessShareLock, строковые блокировки не устанавливаются, что видно в pg_locks. |
| 2 | 2 | ✅Выполнено | На уровне SERIALIZABLE при чтении по индексу и последующих вставках в "чужие" диапазоны для двух пересекающихся транзакций возникла ошибка сериализации, что демонстрирует работу предикатных блокировок и алгоритма SSI. |
| 2 | 3 | ✅Выполнено | При включённых log_lock_waits = on и deadlock_timeout = 100ms долгий UPDATE, ожидающий строковую блокировку, породил в журнале сообщение о ожидании блокировки с указанием процесса, типа блокировки и SQL‑оператора. |
| 3 | 1 | ✅Выполнено | Обновление одной и той же строки в трёх сеансах показало, что первая транзакция удерживает строковую блокировку (tuple ExclusiveLock), а последующие транзакции становятся в очередь ожидания, что отражается в pg_locks. |
| 3 | 2 | ✅Выполнено | На таблице deadlock3_test воспроизведена взаимоблокировка трёх транзакций при каскадных UPDATE; журнал подробно описал цикл T1>T2>T3>T1 с привязкой к конкретным запросам и PID процессов. |
| 3 | 3 | ✅Выполнено | Показано, что при одном UPDATE в каждой транзакции возникает не взаимоблокировка, а обычное ожидание блокировки; для deadlock требуется как минимум два "шага" ожиданий в каждой транзакции (обновление строк в разном порядке). |
| 4 | 1 | ✅Выполнено | Открытый курсор на таблице cursor_pin_test после FETCH удерживает страницу в буферном кеше: в pg_buffercache для нужного блока pinning_backends = 1, что подтверждает наличие buffer pin. |
| 4 | 2 | ✅Выполнено | Обычный VACUUM по таблице с открытым курсором успешно завершился без ожиданий, показывая, что pinned‑страницы могут быть просто пропущены и обработаны последующими проходами очистки. |
| 4 | 3 | ✅Выполнено | При VACUUM (FREEZE, VERBOSE) и открытом курсоре процесс VACUUM попал в ожидание события BufferPin в pg_stat_activity и продолжил работу только после закрытия курсора, что демонстрирует зависимость заморозки от снятия buffer pin. |

## Анализ и выводы

### Основные наблюдения

1. Статистические представления pg_stat_all_tables и семейство pg_stat_* позволяют напрямую связать действия DML с внутренними счётчиками: INSERT и DELETE корректно отражаются в n_tup_ins и n_tup_del, число живых и мёртвых кортежей (n_live_tup, n_dead_tup) соответствует фактическому состоянию таблицы, а VACUUM перерабатывает мёртвые строки, не сбрасывая накопительные счётчики.  
2. Обычные операции чтения (SELECT на Read Committed) используют MVCC и требуют только "лёгких" блокировок уровня объекта (AccessShareLock на таблицу и индекс), тогда как операции записи (UPDATE) добавляют строковые блокировки, формируют очередь ожидания и при неблагоприятном порядке обращений могут приводить к взаимоблокировкам.  
3. Журнал сообщений сервера при включённом логировании ожиданий (log_lock_waits) и при обнаружении deadlock даёт достаточно контекста для диагностики: видно, какие процессы и запросы блокируют друг друга, какие типы блокировок ожидаются и на каких объектах (строка, транзакция, таблица).  
4. Курсоры и операции обслуживания (VACUUM/VACUUM FREEZE) тесно связаны с блокировками в памяти: buffer pin от открытого курсора не мешает обычному VACUUM, но заставляет VACUUM FREEZE ждать освобождения страницы, что фиксируется через ожидание BufferPin и влияет на время работы заморозки.

### Сравнительный анализ

#### Блокировки объектов и строк

- Чтение на уровне Read Committed захватывает только разделяемые блокировки объекта (AccessShareLock) и не блокирует другие читатели и большинство записей, тогда как UPDATE устанавливает RowExclusiveLock на таблицу и эксклюзивные блокировки на отдельные кортежи, формируя очередь ожидания для конкурирующих транзакций.  
- Две транзакции с одним UPDATE на одну и ту же строку приводят лишь к ожиданию блокировки второй транзакцией, но не к взаимоблокировке; deadlock возникает при более сложных сценариях, когда каждая транзакция уже удерживает один ресурс и ждёт другой, что хорошо видно на примере трёх транзакций, обновляющих строки в цикле.  

#### Блокировки в памяти и поведение VACUUM

- Обычный VACUUM достаточно толерантен к buffer pin: при открытых курсорах он может завершиться без долгих ожиданий, оставив часть работы на последующие проходы очистки, если страница в данный момент закреплена в кеше.  
- VACUUM FREEZE более чувствителен к закреплённым буферам: для заморозки старых версий строк ему приходится ждать снятия pin, поэтому процесс VACUUM может оказаться в состоянии ожидания BufferPin до закрытия курсора, что удлиняет время обслуживания и подчёркивает важность аккуратной работы с долгоживущими курсорами в системах с интенсивной заморозкой.
